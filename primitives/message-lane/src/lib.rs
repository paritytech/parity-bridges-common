// Copyright 2019-2020 Parity Technologies (UK) Ltd.
// This file is part of Parity Bridges Common.

// Parity Bridges Common is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity Bridges Common is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity Bridges Common.  If not, see <http://www.gnu.org/licenses/>.

//! Primitives for sending and receiving Substrate <-> Substrate messages.

#![cfg_attr(not(feature = "std"), no_std)]
// RuntimeApi generated functions
#![allow(clippy::too_many_arguments)]
// Generated by `DecodeLimit::decode_with_depth_limit`
#![allow(clippy::unnecessary_mut_passed)]

use codec::{Decode, Encode};
use frame_support::{Parameter, RuntimeDebug};
use sp_api::decl_runtime_apis;
use sp_std::prelude::*;

/// Lane identifier.
pub type LaneId = [u8; 4];

/// Message nonce. Valid messages will never have 0 nonce.
pub type MessageNonce = u64;

/// Message key (unique message identifier) as it is stored in the storage.
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug)]
pub struct MessageKey {
	/// ID of the message lane.
	pub lane_id: LaneId,
	/// Message nonce.
	pub nonce: MessageNonce,
}

/// Message as it is stored in the storage.
#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug)]
pub struct Message<Payload> {
	/// Message key.
	pub key: MessageKey,
	/// Message payload.
	pub payload: Payload,
}

/// Message processing result.
pub enum MessageResult<Payload> {
	/// Message has been processed and should not be queued.
	Processed,
	/// Message has NOT been processed and should be queued for processing later.
	NotProcessed(Message<Payload>),
}

/// Called when inbound message is received.
pub trait OnMessageReceived<Payload> {
	/// Called when inbound message is received.
	///
	/// It is up to the implementers of this trait to determine whether the message
	/// is invalid (i.e. improperly encoded, has too large weight, ...) or not. And,
	/// if message is invalid, then it should be dropped immediately (by returning
	/// `MessageResult::Processed`), or it'll block the lane forever.
	fn on_message_received(&mut self, message: Message<Payload>) -> MessageResult<Payload>;
}

/// Inbound lane data.
#[derive(Encode, Decode, Clone)]
pub struct InboundLaneData {
	/// Nonce of oldest message that we haven't processed yet. May point to not-yet-received message if
	/// lane is currently empty.
	pub oldest_unprocessed_nonce: MessageNonce,
	/// Nonce of latest message that we have received from bridged chain.
	pub latest_received_nonce: MessageNonce,
}

impl Default for InboundLaneData {
	fn default() -> Self {
		InboundLaneData {
			// it is 1 because we're processing everything in [oldest_unprocessed_nonce; latest_received_nonce]
			oldest_unprocessed_nonce: 1,
			latest_received_nonce: 0,
		}
	}
}

/// Outbound lane data.
#[derive(Encode, Decode, Clone)]
pub struct OutboundLaneData {
	/// Nonce of oldest message that we haven't yet pruned. May point to not-yet-generated message if
	/// all sent messages are already pruned.
	pub oldest_unpruned_nonce: MessageNonce,
	/// Nonce of latest message, received by bridged chain.
	pub latest_received_nonce: MessageNonce,
	/// Nonce of latest message, processed by bridged chain.
	pub latest_processed_nonce: MessageNonce,
	/// Nonce of latest message, generated by us.
	pub latest_generated_nonce: MessageNonce,
}

impl Default for OutboundLaneData {
	fn default() -> Self {
		OutboundLaneData {
			// it is 1 because we're pruning everything in [oldest_unpruned_nonce; latest_received_nonce]
			oldest_unpruned_nonce: 1,
			latest_received_nonce: 0,
			latest_processed_nonce: 0,
			latest_generated_nonce: 0,
		}
	}
}

decl_runtime_apis! {
	/// Outbound message lane API.
	pub trait OutboundLaneApi<Payload: Decode> {
		/// Returns nonce of the latest message, received by bridged chain.
		fn latest_received_nonce(lane: LaneId) -> MessageNonce;
		/// Returns nonce of the latest message, processed by bridged chain.
		fn latest_processed_nonce(lane: LaneId) -> MessageNonce;
		/// Returns nonce of the latest message, generated by given lane.
		fn latest_generated_nonce(lane: LaneId) -> MessageNonce;
	}

	/// Inbound message lane API.
	pub trait InboundLaneApi {
		/// Returns nonce of the latest message, received by given lane.
		fn latest_received_nonce(lane: LaneId) -> MessageNonce;
		/// Returns nonce of the latest message, processed by given lane.
		fn latest_processed_nonce(lane: LaneId) -> MessageNonce;
	}
}

/// Bridged chain API.
///
/// **This** and bridged chain may have totally different APIs and proofs. But
/// we only care about bridged chain here. Because we need to check proofs from runtime.
///
/// It is assumed by design that we are not generating or checking **this**
/// chain proofs from runtime. They may be generated by RPC methods or something
/// similar, that is external to runtime.
///
/// All implementations of this trait should only work with finalized data that
/// can't change. Wrong implementation may lead to invalid lane states (i.e. lane
/// that's stuck) and/or processing messages without paying fees.
pub trait BridgedHeaderChain<Payload> {
	/// Error type.
	type Error: std::fmt::Debug + Into<&'static str>;

	/// Proof that messages are sent to this chain.
	type MessagesProof: Parameter;
	/// Proof that some messages, sent from this chain, have been received by bridged chain.
	type MessagesReceivingProof: Parameter;
	/// Proof that some messages, sent from this chain, have been processed by bridged chain.
	type MessagesProcessingProof: Parameter;

	/// Verify messages proof and return proved messages.
	fn verify_messages_proof(proof: Self::MessagesProof) -> Result<Vec<Message<Payload>>, Self::Error>;
	/// Verify messages receiving proof and return lane && nonce of the latest recevied message.
	fn verify_messages_receiving_proof(
		proof: Self::MessagesReceivingProof,
	) -> Result<(LaneId, MessageNonce), Self::Error>;
	/// Verify messages processing proof and return lane && nonce of the latest processed message.
	fn verify_messages_processing_proof(
		proof: Self::MessagesProcessingProof,
	) -> Result<(LaneId, MessageNonce), Self::Error>;
}

/// Lane message verifier.
///
/// This has many uses:
///
/// 1) the most important -if bridged chain has some requirements to accepting transaction-with-message
/// to the transaction pool, runtime **MUST** guarantee that it won't accept any message that can't
/// be accepted by the bridged chain. The example could be - for BTC chain, the message (which in turn
/// may be BTC transaction) size must not be larger than 1Mb (or whatever limit is currently imposed by
/// BTC consensus rules);
/// 2) if message lanes should have some security, then it must be checked by this verifier. I.e. you
/// can only accept Lane1 messages from Submitter1, Lane2 messages for those who has submitted first
/// message, disable Lane3 until some block, ...
pub trait LaneMessageVerifier<Submitter, Payload> {
	/// Error type.
	type Error: std::fmt::Debug + Into<&'static str>;

	/// Verify message payload and return Ok(()) if message is valid and should be sent over lane.
	fn verify_message(
		submitter: &Submitter,
		lane: &LaneId,
		payload: &Payload,
	) -> Result<(), Self::Error>;
}
