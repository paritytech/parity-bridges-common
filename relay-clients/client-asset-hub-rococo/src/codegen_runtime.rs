// Copyright (C) Parity Technologies (UK) Ltd.
// This file is part of Parity Bridges Common.

// Parity Bridges Common is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity Bridges Common is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity Bridges Common.  If not, see <http://www.gnu.org/licenses/>.

//! Autogenerated runtime API
//! THIS FILE WAS AUTOGENERATED USING parity-bridges-common::runtime-codegen
//! EXECUTED COMMAND: target/debug/runtime-codegen --from-wasm-file
//! asset_hub_rococo_runtime.compact.compressed.wasm

#[allow(dead_code, unused_imports, non_camel_case_types, unreachable_patterns)]
#[allow(clippy::all)]
#[allow(rustdoc::broken_intra_doc_links)]
pub mod api {
	#[allow(unused_imports)]
	mod root_mod {
		pub use super::*;
	}
	pub mod runtime_types {
		use super::runtime_types;
		pub mod asset_hub_rococo_runtime {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct BridgeRejectObsoleteHeadersAndMessages;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum OriginCaller {
				#[codec(index = 0)]
				system(
					runtime_types::frame_support::dispatch::RawOrigin<
						::sp_core::crypto::AccountId32,
					>,
				),
				#[codec(index = 31)]
				PolkadotXcm(runtime_types::pallet_xcm::pallet::Origin),
				#[codec(index = 32)]
				CumulusXcm(runtime_types::cumulus_pallet_xcm::pallet::Origin),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum ProxyType {
				#[codec(index = 0)]
				Any,
				#[codec(index = 1)]
				NonTransfer,
				#[codec(index = 2)]
				CancelProxy,
				#[codec(index = 3)]
				Assets,
				#[codec(index = 4)]
				AssetOwner,
				#[codec(index = 5)]
				AssetManager,
				#[codec(index = 6)]
				Collator,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct Runtime;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeCall {
				#[codec(index = 0)]
				System(runtime_types::frame_system::pallet::Call),
				#[codec(index = 1)]
				ParachainSystem(runtime_types::cumulus_pallet_parachain_system::pallet::Call),
				#[codec(index = 3)]
				Timestamp(runtime_types::pallet_timestamp::pallet::Call),
				#[codec(index = 4)]
				ParachainInfo(runtime_types::staging_parachain_info::pallet::Call),
				#[codec(index = 10)]
				Balances(runtime_types::pallet_balances::pallet::Call),
				#[codec(index = 21)]
				CollatorSelection(runtime_types::pallet_collator_selection::pallet::Call),
				#[codec(index = 22)]
				Session(runtime_types::pallet_session::pallet::Call),
				#[codec(index = 30)]
				XcmpQueue(runtime_types::cumulus_pallet_xcmp_queue::pallet::Call),
				#[codec(index = 31)]
				PolkadotXcm(runtime_types::pallet_xcm::pallet::Call),
				#[codec(index = 32)]
				CumulusXcm(runtime_types::cumulus_pallet_xcm::pallet::Call),
				#[codec(index = 34)]
				MessageQueue(runtime_types::pallet_message_queue::pallet::Call),
				#[codec(index = 40)]
				Utility(runtime_types::pallet_utility::pallet::Call),
				#[codec(index = 41)]
				Multisig(runtime_types::pallet_multisig::pallet::Call),
				#[codec(index = 42)]
				Proxy(runtime_types::pallet_proxy::pallet::Call),
				#[codec(index = 45)]
				ToWestendXcmRouter(runtime_types::pallet_xcm_bridge_router::pallet::Call),
				#[codec(index = 50)]
				Assets(runtime_types::pallet_assets::pallet::Call1),
				#[codec(index = 51)]
				Uniques(runtime_types::pallet_uniques::pallet::Call),
				#[codec(index = 52)]
				Nfts(runtime_types::pallet_nfts::pallet::Call),
				#[codec(index = 53)]
				ForeignAssets(runtime_types::pallet_assets::pallet::Call2),
				#[codec(index = 54)]
				NftFractionalization(runtime_types::pallet_nft_fractionalization::pallet::Call),
				#[codec(index = 55)]
				PoolAssets(runtime_types::pallet_assets::pallet::Call3),
				#[codec(index = 56)]
				AssetConversion(runtime_types::pallet_asset_conversion::pallet::Call),
				#[codec(index = 60)]
				AssetRewards(runtime_types::pallet_asset_rewards::pallet::Call),
				#[codec(index = 61)]
				XcmOverAssetHubWestend(runtime_types::pallet_xcm_bridge::pallet::Call),
				#[codec(index = 62)]
				BridgeWestendMessages(runtime_types::pallet_bridge_messages::pallet::Call),
				#[codec(index = 63)]
				BridgeRelayers(runtime_types::pallet_bridge_relayers::pallet::Call),
				#[codec(index = 64)]
				ToWestendOverAssetHubWestendXcmRouter(
					runtime_types::pallet_xcm_bridge_router::pallet::Call,
				),
				#[codec(index = 200)]
				AssetConversionMigration(runtime_types::pallet_asset_conversion_ops::pallet::Call),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeError {
				#[codec(index = 0)]
				System(runtime_types::frame_system::pallet::Error),
				#[codec(index = 1)]
				ParachainSystem(runtime_types::cumulus_pallet_parachain_system::pallet::Error),
				#[codec(index = 10)]
				Balances(runtime_types::pallet_balances::pallet::Error),
				#[codec(index = 21)]
				CollatorSelection(runtime_types::pallet_collator_selection::pallet::Error),
				#[codec(index = 22)]
				Session(runtime_types::pallet_session::pallet::Error),
				#[codec(index = 30)]
				XcmpQueue(runtime_types::cumulus_pallet_xcmp_queue::pallet::Error),
				#[codec(index = 31)]
				PolkadotXcm(runtime_types::pallet_xcm::pallet::Error),
				#[codec(index = 34)]
				MessageQueue(runtime_types::pallet_message_queue::pallet::Error),
				#[codec(index = 40)]
				Utility(runtime_types::pallet_utility::pallet::Error),
				#[codec(index = 41)]
				Multisig(runtime_types::pallet_multisig::pallet::Error),
				#[codec(index = 42)]
				Proxy(runtime_types::pallet_proxy::pallet::Error),
				#[codec(index = 50)]
				Assets(runtime_types::pallet_assets::pallet::Error),
				#[codec(index = 51)]
				Uniques(runtime_types::pallet_uniques::pallet::Error),
				#[codec(index = 52)]
				Nfts(runtime_types::pallet_nfts::pallet::Error),
				#[codec(index = 53)]
				ForeignAssets(runtime_types::pallet_assets::pallet::Error),
				#[codec(index = 54)]
				NftFractionalization(runtime_types::pallet_nft_fractionalization::pallet::Error),
				#[codec(index = 55)]
				PoolAssets(runtime_types::pallet_assets::pallet::Error),
				#[codec(index = 56)]
				AssetConversion(runtime_types::pallet_asset_conversion::pallet::Error),
				#[codec(index = 57)]
				AssetsFreezer(runtime_types::pallet_assets_freezer::pallet::Error),
				#[codec(index = 58)]
				ForeignAssetsFreezer(runtime_types::pallet_assets_freezer::pallet::Error),
				#[codec(index = 59)]
				PoolAssetsFreezer(runtime_types::pallet_assets_freezer::pallet::Error),
				#[codec(index = 60)]
				AssetRewards(runtime_types::pallet_asset_rewards::pallet::Error),
				#[codec(index = 61)]
				XcmOverAssetHubWestend(runtime_types::pallet_xcm_bridge::pallet::Error),
				#[codec(index = 62)]
				BridgeWestendMessages(runtime_types::pallet_bridge_messages::pallet::Error),
				#[codec(index = 63)]
				BridgeRelayers(runtime_types::pallet_bridge_relayers::pallet::Error),
				#[codec(index = 200)]
				AssetConversionMigration(runtime_types::pallet_asset_conversion_ops::pallet::Error),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeEvent {
				#[codec(index = 0)]
				System(runtime_types::frame_system::pallet::Event),
				#[codec(index = 1)]
				ParachainSystem(runtime_types::cumulus_pallet_parachain_system::pallet::Event),
				#[codec(index = 10)]
				Balances(runtime_types::pallet_balances::pallet::Event),
				#[codec(index = 11)]
				TransactionPayment(runtime_types::pallet_transaction_payment::pallet::Event),
				#[codec(index = 13)]
				AssetTxPayment(runtime_types::pallet_asset_conversion_tx_payment::pallet::Event),
				#[codec(index = 21)]
				CollatorSelection(runtime_types::pallet_collator_selection::pallet::Event),
				#[codec(index = 22)]
				Session(runtime_types::pallet_session::pallet::Event),
				#[codec(index = 30)]
				XcmpQueue(runtime_types::cumulus_pallet_xcmp_queue::pallet::Event),
				#[codec(index = 31)]
				PolkadotXcm(runtime_types::pallet_xcm::pallet::Event),
				#[codec(index = 32)]
				CumulusXcm(runtime_types::cumulus_pallet_xcm::pallet::Event),
				#[codec(index = 34)]
				MessageQueue(runtime_types::pallet_message_queue::pallet::Event),
				#[codec(index = 40)]
				Utility(runtime_types::pallet_utility::pallet::Event),
				#[codec(index = 41)]
				Multisig(runtime_types::pallet_multisig::pallet::Event),
				#[codec(index = 42)]
				Proxy(runtime_types::pallet_proxy::pallet::Event),
				#[codec(index = 45)]
				ToWestendXcmRouter(runtime_types::pallet_xcm_bridge_router::pallet::Event),
				#[codec(index = 50)]
				Assets(runtime_types::pallet_assets::pallet::Event1),
				#[codec(index = 51)]
				Uniques(runtime_types::pallet_uniques::pallet::Event),
				#[codec(index = 52)]
				Nfts(runtime_types::pallet_nfts::pallet::Event),
				#[codec(index = 53)]
				ForeignAssets(runtime_types::pallet_assets::pallet::Event2),
				#[codec(index = 54)]
				NftFractionalization(runtime_types::pallet_nft_fractionalization::pallet::Event),
				#[codec(index = 55)]
				PoolAssets(runtime_types::pallet_assets::pallet::Event1),
				#[codec(index = 56)]
				AssetConversion(runtime_types::pallet_asset_conversion::pallet::Event),
				#[codec(index = 57)]
				AssetsFreezer(runtime_types::pallet_assets_freezer::pallet::Event1),
				#[codec(index = 58)]
				ForeignAssetsFreezer(runtime_types::pallet_assets_freezer::pallet::Event2),
				#[codec(index = 59)]
				PoolAssetsFreezer(runtime_types::pallet_assets_freezer::pallet::Event1),
				#[codec(index = 60)]
				AssetRewards(runtime_types::pallet_asset_rewards::pallet::Event),
				#[codec(index = 61)]
				XcmOverAssetHubWestend(runtime_types::pallet_xcm_bridge::pallet::Event),
				#[codec(index = 62)]
				BridgeWestendMessages(runtime_types::pallet_bridge_messages::pallet::Event),
				#[codec(index = 63)]
				BridgeRelayers(runtime_types::pallet_bridge_relayers::pallet::Event),
				#[codec(index = 64)]
				ToWestendOverAssetHubWestendXcmRouter(
					runtime_types::pallet_xcm_bridge_router::pallet::Event,
				),
				#[codec(index = 200)]
				AssetConversionMigration(runtime_types::pallet_asset_conversion_ops::pallet::Event),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeFreezeReason {
				#[codec(index = 60)]
				AssetRewards(runtime_types::pallet_asset_rewards::pallet::FreezeReason),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeHoldReason {
				#[codec(index = 54)]
				NftFractionalization(
					runtime_types::pallet_nft_fractionalization::pallet::HoldReason,
				),
				#[codec(index = 60)]
				AssetRewards(runtime_types::pallet_asset_rewards::pallet::HoldReason),
				#[codec(index = 61)]
				XcmOverAssetHubWestend(runtime_types::pallet_xcm_bridge::pallet::HoldReason),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct SessionKeys {
				pub aura: runtime_types::sp_consensus_aura::sr25519::app_sr25519::Public,
			}
		}
		pub mod bounded_collections {
			use super::runtime_types;
			pub mod bounded_btree_map {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct BoundedBTreeMap<_0, _1>(
					pub ::subxt::ext::subxt_core::utils::KeyedVec<_0, _1>,
				);
			}
			pub mod bounded_btree_set {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct BoundedBTreeSet<_0>(pub ::subxt::ext::subxt_core::alloc::vec::Vec<_0>);
			}
			pub mod bounded_vec {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct BoundedVec<_0>(pub ::subxt::ext::subxt_core::alloc::vec::Vec<_0>);
			}
			pub mod weak_bounded_vec {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct WeakBoundedVec<_0>(pub ::subxt::ext::subxt_core::alloc::vec::Vec<_0>);
			}
		}
		pub mod bp_header_chain {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum HeaderChainError {
				#[codec(index = 0)]
				UnknownHeader,
				#[codec(index = 1)]
				StorageProof(runtime_types::bp_runtime::storage_proof::StorageProofError),
			}
		}
		pub mod bp_messages {
			use super::runtime_types;
			pub mod lane {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct HashedLaneId(pub ::subxt::ext::subxt_core::utils::H256);
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum LaneState {
					#[codec(index = 0)]
					Opened,
					#[codec(index = 1)]
					Closed,
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct DeliveredMessages {
				pub begin: ::core::primitive::u64,
				pub end: ::core::primitive::u64,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct InboundLaneData<_0> {
				pub relayers: ::subxt::ext::subxt_core::alloc::vec::Vec<
					runtime_types::bp_messages::UnrewardedRelayer<_0>,
				>,
				pub last_confirmed_nonce: ::core::primitive::u64,
				pub state: runtime_types::bp_messages::lane::LaneState,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct MessageKey<_0> {
				pub lane_id: _0,
				pub nonce: ::core::primitive::u64,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum MessagesOperatingMode {
				#[codec(index = 0)]
				Basic(runtime_types::bp_runtime::BasicOperatingMode),
				#[codec(index = 1)]
				RejectingOutboundMessages,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct OutboundLaneData {
				pub oldest_unpruned_nonce: ::core::primitive::u64,
				pub latest_received_nonce: ::core::primitive::u64,
				pub latest_generated_nonce: ::core::primitive::u64,
				pub state: runtime_types::bp_messages::lane::LaneState,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct ReceivedMessages<_0, _1> {
				pub lane: _1,
				pub receive_results: ::subxt::ext::subxt_core::alloc::vec::Vec<(
					::core::primitive::u64,
					runtime_types::bp_messages::ReceptionResult<_0>,
				)>,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum ReceptionResult<_0> {
				#[codec(index = 0)]
				Dispatched(runtime_types::bp_runtime::messages::MessageDispatchResult<_0>),
				#[codec(index = 1)]
				InvalidNonce,
				#[codec(index = 2)]
				TooManyUnrewardedRelayers,
				#[codec(index = 3)]
				TooManyUnconfirmedMessages,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct UnrewardedRelayer<_0> {
				pub relayer: _0,
				pub messages: runtime_types::bp_messages::DeliveredMessages,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum VerificationError {
				#[codec(index = 0)]
				EmptyMessageProof,
				#[codec(index = 1)]
				HeaderChain(runtime_types::bp_header_chain::HeaderChainError),
				#[codec(index = 2)]
				InboundLaneStorage(runtime_types::bp_runtime::storage_proof::StorageProofError),
				#[codec(index = 3)]
				InvalidMessageWeight,
				#[codec(index = 4)]
				MessagesCountMismatch,
				#[codec(index = 5)]
				MessageStorage(runtime_types::bp_runtime::storage_proof::StorageProofError),
				#[codec(index = 6)]
				MessageTooLarge,
				#[codec(index = 7)]
				OutboundLaneStorage(runtime_types::bp_runtime::storage_proof::StorageProofError),
				#[codec(index = 8)]
				StorageProof(runtime_types::bp_runtime::storage_proof::StorageProofError),
				#[codec(index = 9)]
				Other,
			}
		}
		pub mod bp_relayers {
			use super::runtime_types;
			pub mod registration {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct Registration<_0, _1> {
					pub valid_till: _0,
					pub stake: _1,
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum RewardsAccountOwner {
				#[codec(index = 0)]
				ThisChain,
				#[codec(index = 1)]
				BridgedChain,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct RewardsAccountParams<_0> {
				pub owner: runtime_types::bp_relayers::RewardsAccountOwner,
				pub bridged_chain_id: [::core::primitive::u8; 4usize],
				pub lane_id: _0,
			}
		}
		pub mod bp_runtime {
			use super::runtime_types;
			pub mod messages {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct MessageDispatchResult<_0> {
					pub unspent_weight: ::sp_weights::Weight,
					pub dispatch_level_result: _0,
				}
			}
			pub mod storage_proof {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum StorageProofError {
					#[codec(index = 0)]
					UnableToGenerateTrieProof,
					#[codec(index = 1)]
					InvalidProof,
					#[codec(index = 2)]
					UnsortedEntries,
					#[codec(index = 3)]
					UnavailableKey,
					#[codec(index = 4)]
					EmptyVal,
					#[codec(index = 5)]
					DecodeError,
					#[codec(index = 6)]
					UnusedKey,
					#[codec(index = 7)]
					StorageRootMismatch,
					#[codec(index = 8)]
					StorageValueUnavailable,
					#[codec(index = 9)]
					DuplicateNodes,
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum BasicOperatingMode {
				#[codec(index = 0)]
				Normal,
				#[codec(index = 1)]
				Halted,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum OwnedBridgeModuleError {
				#[codec(index = 0)]
				Halted,
			}
		}
		pub mod bp_xcm_bridge {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct Bridge {
				pub bridge_origin_relative_location: ::subxt::ext::subxt_core::alloc::boxed::Box<
					runtime_types::xcm::VersionedLocation,
				>,
				pub bridge_origin_universal_location: ::subxt::ext::subxt_core::alloc::boxed::Box<
					runtime_types::xcm::VersionedInteriorLocation,
				>,
				pub bridge_destination_universal_location:
					::subxt::ext::subxt_core::alloc::boxed::Box<
						runtime_types::xcm::VersionedInteriorLocation,
					>,
				pub state: runtime_types::bp_xcm_bridge::BridgeState,
				pub deposit: ::core::option::Option<
					runtime_types::bp_xcm_bridge::Deposit<
						::sp_core::crypto::AccountId32,
						::core::primitive::u128,
					>,
				>,
				pub lane_id: runtime_types::bp_messages::lane::HashedLaneId,
				pub maybe_notify: ::core::option::Option<runtime_types::bp_xcm_bridge::Receiver>,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct BridgeId(pub ::subxt::ext::subxt_core::utils::H256);
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum BridgeLocationsError {
				#[codec(index = 0)]
				NonUniversalLocation,
				#[codec(index = 1)]
				InvalidBridgeOrigin,
				#[codec(index = 2)]
				InvalidBridgeDestination,
				#[codec(index = 3)]
				DestinationIsLocal,
				#[codec(index = 4)]
				UnreachableDestination,
				#[codec(index = 5)]
				UnsupportedDestinationLocation,
				#[codec(index = 6)]
				UnsupportedXcmVersion,
				#[codec(index = 7)]
				UnsupportedLaneIdType,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum BridgeState {
				#[codec(index = 0)]
				Opened,
				#[codec(index = 1)]
				SoftSuspended,
				#[codec(index = 2)]
				HardSuspended,
				#[codec(index = 3)]
				Closed,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct Deposit<_0, _1> {
				pub account: _0,
				pub amount: _1,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct Receiver {
				pub pallet_index: ::core::primitive::u8,
				pub call_index: ::core::primitive::u8,
			}
		}
		pub mod bp_xcm_bridge_router {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct BridgeState {
				pub delivery_fee_factor: runtime_types::sp_arithmetic::fixed_point::FixedU128,
				pub is_congested: ::core::primitive::bool,
			}
		}
		pub mod cumulus_pallet_parachain_system {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
                    set_validation_data {
                        data: runtime_types::cumulus_primitives_parachain_inherent::ParachainInherentData,
                    },
                    #[codec(index = 1)]
                    sudo_send_upward_message {
                        message: ::subxt::ext::subxt_core::alloc::vec::Vec<
                            ::core::primitive::u8,
                        >,
                    },
                }
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					OverlappingUpgrades,
					#[codec(index = 1)]
					ProhibitedByPolkadot,
					#[codec(index = 2)]
					TooBig,
					#[codec(index = 3)]
					ValidationDataNotAvailable,
					#[codec(index = 4)]
					HostConfigurationNotAvailable,
					#[codec(index = 5)]
					NotScheduled,
					#[codec(index = 6)]
					NothingAuthorized,
					#[codec(index = 7)]
					Unauthorized,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ValidationFunctionStored,
					#[codec(index = 1)]
					ValidationFunctionApplied { relay_chain_block_num: ::core::primitive::u32 },
					#[codec(index = 2)]
					ValidationFunctionDiscarded,
					#[codec(index = 3)]
					DownwardMessagesReceived { count: ::core::primitive::u32 },
					#[codec(index = 4)]
					DownwardMessagesProcessed {
						weight_used: ::sp_weights::Weight,
						dmq_head: ::subxt::ext::subxt_core::utils::H256,
					},
					#[codec(index = 5)]
					UpwardMessageSent {
						message_hash: ::core::option::Option<[::core::primitive::u8; 32usize]>,
					},
				}
			}
			pub mod relay_state_snapshot {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct MessagingStateSnapshot {
                    pub dmq_mqc_head: ::subxt::ext::subxt_core::utils::H256,
                    pub relay_dispatch_queue_remaining_capacity: runtime_types::cumulus_pallet_parachain_system::relay_state_snapshot::RelayDispatchQueueRemainingCapacity,
                    pub ingress_channels: ::subxt::ext::subxt_core::alloc::vec::Vec<
                        (
                            runtime_types::polkadot_parachain_primitives::primitives::Id,
                            runtime_types::polkadot_primitives::v8::AbridgedHrmpChannel,
                        ),
                    >,
                    pub egress_channels: ::subxt::ext::subxt_core::alloc::vec::Vec<
                        (
                            runtime_types::polkadot_parachain_primitives::primitives::Id,
                            runtime_types::polkadot_primitives::v8::AbridgedHrmpChannel,
                        ),
                    >,
                }
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct RelayDispatchQueueRemainingCapacity {
					pub remaining_count: ::core::primitive::u32,
					pub remaining_size: ::core::primitive::u32,
				}
			}
			pub mod unincluded_segment {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct Ancestor<_0> {
                    pub used_bandwidth: runtime_types::cumulus_pallet_parachain_system::unincluded_segment::UsedBandwidth,
                    pub para_head_hash: ::core::option::Option<_0>,
                    pub consumed_go_ahead_signal: ::core::option::Option<
                        runtime_types::polkadot_primitives::v8::UpgradeGoAhead,
                    >,
                }
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct HrmpChannelUpdate {
					pub msg_count: ::core::primitive::u32,
					pub total_bytes: ::core::primitive::u32,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct SegmentTracker<_0> {
                    pub used_bandwidth: runtime_types::cumulus_pallet_parachain_system::unincluded_segment::UsedBandwidth,
                    pub hrmp_watermark: ::core::option::Option<::core::primitive::u32>,
                    pub consumed_go_ahead_signal: ::core::option::Option<
                        runtime_types::polkadot_primitives::v8::UpgradeGoAhead,
                    >,
                    #[codec(skip)]
                    pub __ignore: ::core::marker::PhantomData<_0>,
                }
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct UsedBandwidth {
                    pub ump_msg_count: ::core::primitive::u32,
                    pub ump_total_bytes: ::core::primitive::u32,
                    pub hrmp_outgoing: ::subxt::ext::subxt_core::utils::KeyedVec<
                        runtime_types::polkadot_parachain_primitives::primitives::Id,
                        runtime_types::cumulus_pallet_parachain_system::unincluded_segment::HrmpChannelUpdate,
                    >,
                }
			}
		}
		pub mod cumulus_pallet_weight_reclaim {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct StorageWeightReclaim<_1>(pub _1);
		}
		pub mod cumulus_pallet_xcm {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					InvalidFormat([::core::primitive::u8; 32usize]),
					#[codec(index = 1)]
					UnsupportedVersion([::core::primitive::u8; 32usize]),
					#[codec(index = 2)]
					ExecutedDownward(
						[::core::primitive::u8; 32usize],
						runtime_types::staging_xcm::v5::traits::Outcome,
					),
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Origin {
					#[codec(index = 0)]
					Relay,
					#[codec(index = 1)]
					SiblingParachain(runtime_types::polkadot_parachain_primitives::primitives::Id),
				}
			}
		}
		pub mod cumulus_pallet_xcmp_queue {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 1)]
					suspend_xcm_execution,
					#[codec(index = 2)]
					resume_xcm_execution,
					#[codec(index = 3)]
					update_suspend_threshold { new: ::core::primitive::u32 },
					#[codec(index = 4)]
					update_drop_threshold { new: ::core::primitive::u32 },
					#[codec(index = 5)]
					update_resume_threshold { new: ::core::primitive::u32 },
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					BadQueueConfig,
					#[codec(index = 1)]
					AlreadySuspended,
					#[codec(index = 2)]
					AlreadyResumed,
					#[codec(index = 3)]
					TooManyActiveOutboundChannels,
					#[codec(index = 4)]
					TooBig,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					XcmpMessageSent { message_hash: [::core::primitive::u8; 32usize] },
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct OutboundChannelDetails {
				pub recipient: runtime_types::polkadot_parachain_primitives::primitives::Id,
				pub state: runtime_types::cumulus_pallet_xcmp_queue::OutboundState,
				pub signals_exist: ::core::primitive::bool,
				pub first_index: ::core::primitive::u16,
				pub last_index: ::core::primitive::u16,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum OutboundState {
				#[codec(index = 0)]
				Ok,
				#[codec(index = 1)]
				Suspended,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct QueueConfigData {
				pub suspend_threshold: ::core::primitive::u32,
				pub drop_threshold: ::core::primitive::u32,
				pub resume_threshold: ::core::primitive::u32,
			}
		}
		pub mod cumulus_primitives_core {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum AggregateMessageOrigin {
				#[codec(index = 0)]
				Here,
				#[codec(index = 1)]
				Parent,
				#[codec(index = 2)]
				Sibling(runtime_types::polkadot_parachain_primitives::primitives::Id),
			}
		}
		pub mod cumulus_primitives_parachain_inherent {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct MessageQueueChain(pub ::subxt::ext::subxt_core::utils::H256);
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct ParachainInherentData {
				pub validation_data:
					runtime_types::polkadot_primitives::v8::PersistedValidationData<
						::subxt::ext::subxt_core::utils::H256,
						::core::primitive::u32,
					>,
				pub relay_chain_state: runtime_types::sp_trie::storage_proof::StorageProof,
				pub downward_messages: ::subxt::ext::subxt_core::alloc::vec::Vec<
					runtime_types::polkadot_core_primitives::InboundDownwardMessage<
						::core::primitive::u32,
					>,
				>,
				pub horizontal_messages: ::subxt::ext::subxt_core::utils::KeyedVec<
					runtime_types::polkadot_parachain_primitives::primitives::Id,
					::subxt::ext::subxt_core::alloc::vec::Vec<
						runtime_types::polkadot_core_primitives::InboundHrmpMessage<
							::core::primitive::u32,
						>,
					>,
				>,
			}
		}
		pub mod frame_metadata_hash_extension {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct CheckMetadataHash {
				pub mode: runtime_types::frame_metadata_hash_extension::Mode,
			}
			#[derive(
				::codec::Decode, ::codec::Encode, Clone, Debug, Eq, PartialEq, scale_info::TypeInfo,
			)]
			pub enum Mode {
				#[codec(index = 0)]
				Disabled,
				#[codec(index = 1)]
				Enabled,
			}
		}
		pub mod frame_support {
			use super::runtime_types;
			pub mod dispatch {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum DispatchClass {
					#[codec(index = 0)]
					Normal,
					#[codec(index = 1)]
					Operational,
					#[codec(index = 2)]
					Mandatory,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Pays {
					#[codec(index = 0)]
					Yes,
					#[codec(index = 1)]
					No,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct PerDispatchClass<_0> {
					pub normal: _0,
					pub operational: _0,
					pub mandatory: _0,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum RawOrigin<_0> {
					#[codec(index = 0)]
					Root,
					#[codec(index = 1)]
					Signed(_0),
					#[codec(index = 2)]
					None,
				}
			}
			pub mod traits {
				use super::runtime_types;
				pub mod messages {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum ProcessMessageError {
						#[codec(index = 0)]
						BadFormat,
						#[codec(index = 1)]
						Corrupt,
						#[codec(index = 2)]
						Unsupported,
						#[codec(index = 3)]
						Overweight(::sp_weights::Weight),
						#[codec(index = 4)]
						Yield,
						#[codec(index = 5)]
						StackLimitReached,
					}
				}
				pub mod schedule {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum DispatchTime<_0> {
						#[codec(index = 0)]
						At(_0),
						#[codec(index = 1)]
						After(_0),
					}
				}
				pub mod tokens {
					use super::runtime_types;
					pub mod fungible {
						use super::runtime_types;
						#[derive(
							::codec::Decode,
							::codec::Encode,
							::subxt::ext::subxt_core::ext::codec::CompactAs,
							Clone,
							Debug,
							PartialEq,
						)]
						pub struct HoldConsideration(pub ::core::primitive::u128);
					}
					pub mod misc {
						use super::runtime_types;
						#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
						pub enum BalanceStatus {
							#[codec(index = 0)]
							Free,
							#[codec(index = 1)]
							Reserved,
						}
						#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
						pub struct IdAmount<_0, _1> {
							pub id: _0,
							pub amount: _1,
						}
					}
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct PalletId(pub [::core::primitive::u8; 8usize]);
		}
		pub mod frame_system {
			use super::runtime_types;
			pub mod extensions {
				use super::runtime_types;
				pub mod check_genesis {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct CheckGenesis;
				}
				pub mod check_mortality {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct CheckMortality(pub ::sp_runtime::generic::Era);
				}
				pub mod check_non_zero_sender {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct CheckNonZeroSender;
				}
				pub mod check_nonce {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct CheckNonce(#[codec(compact)] pub ::core::primitive::u32);
				}
				pub mod check_spec_version {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct CheckSpecVersion;
				}
				pub mod check_tx_version {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct CheckTxVersion;
				}
				pub mod check_weight {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct CheckWeight;
				}
			}
			pub mod limits {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct BlockLength {
					pub max: runtime_types::frame_support::dispatch::PerDispatchClass<
						::core::primitive::u32,
					>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct BlockWeights {
					pub base_block: ::sp_weights::Weight,
					pub max_block: ::sp_weights::Weight,
					pub per_class: runtime_types::frame_support::dispatch::PerDispatchClass<
						runtime_types::frame_system::limits::WeightsPerClass,
					>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct WeightsPerClass {
					pub base_extrinsic: ::sp_weights::Weight,
					pub max_extrinsic: ::core::option::Option<::sp_weights::Weight>,
					pub max_total: ::core::option::Option<::sp_weights::Weight>,
					pub reserved: ::core::option::Option<::sp_weights::Weight>,
				}
			}
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					remark {
						remark: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 1)]
					set_heap_pages { pages: ::core::primitive::u64 },
					#[codec(index = 2)]
					set_code {
						code: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 3)]
					set_code_without_checks {
						code: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 4)]
					set_storage {
						items: ::subxt::ext::subxt_core::alloc::vec::Vec<(
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						)>,
					},
					#[codec(index = 5)]
					kill_storage {
						keys: ::subxt::ext::subxt_core::alloc::vec::Vec<
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						>,
					},
					#[codec(index = 6)]
					kill_prefix {
						prefix: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						subkeys: ::core::primitive::u32,
					},
					#[codec(index = 7)]
					remark_with_event {
						remark: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 9)]
					authorize_upgrade { code_hash: ::subxt::ext::subxt_core::utils::H256 },
					#[codec(index = 10)]
					authorize_upgrade_without_checks {
						code_hash: ::subxt::ext::subxt_core::utils::H256,
					},
					#[codec(index = 11)]
					apply_authorized_upgrade {
						code: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidSpecName,
					#[codec(index = 1)]
					SpecVersionNeedsToIncrease,
					#[codec(index = 2)]
					FailedToExtractRuntimeVersion,
					#[codec(index = 3)]
					NonDefaultComposite,
					#[codec(index = 4)]
					NonZeroRefCount,
					#[codec(index = 5)]
					CallFiltered,
					#[codec(index = 6)]
					MultiBlockMigrationsOngoing,
					#[codec(index = 7)]
					NothingAuthorized,
					#[codec(index = 8)]
					Unauthorized,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ExtrinsicSuccess {
						dispatch_info: runtime_types::frame_system::DispatchEventInfo,
					},
					#[codec(index = 1)]
					ExtrinsicFailed {
						dispatch_error: runtime_types::sp_runtime::DispatchError,
						dispatch_info: runtime_types::frame_system::DispatchEventInfo,
					},
					#[codec(index = 2)]
					CodeUpdated,
					#[codec(index = 3)]
					NewAccount { account: ::sp_core::crypto::AccountId32 },
					#[codec(index = 4)]
					KilledAccount { account: ::sp_core::crypto::AccountId32 },
					#[codec(index = 5)]
					Remarked {
						sender: ::sp_core::crypto::AccountId32,
						hash: ::subxt::ext::subxt_core::utils::H256,
					},
					#[codec(index = 6)]
					UpgradeAuthorized {
						code_hash: ::subxt::ext::subxt_core::utils::H256,
						check_version: ::core::primitive::bool,
					},
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct AccountInfo<_0, _1> {
				pub nonce: _0,
				pub consumers: ::core::primitive::u32,
				pub providers: ::core::primitive::u32,
				pub sufficients: ::core::primitive::u32,
				pub data: _1,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct CodeUpgradeAuthorization {
				pub code_hash: ::subxt::ext::subxt_core::utils::H256,
				pub check_version: ::core::primitive::bool,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct DispatchEventInfo {
				pub weight: ::sp_weights::Weight,
				pub class: runtime_types::frame_support::dispatch::DispatchClass,
				pub pays_fee: runtime_types::frame_support::dispatch::Pays,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct EventRecord<_0, _1> {
				pub phase: runtime_types::frame_system::Phase,
				pub event: _0,
				pub topics: ::subxt::ext::subxt_core::alloc::vec::Vec<_1>,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct LastRuntimeUpgradeInfo {
				#[codec(compact)]
				pub spec_version: ::core::primitive::u32,
				pub spec_name: ::subxt::ext::subxt_core::alloc::string::String,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum Phase {
				#[codec(index = 0)]
				ApplyExtrinsic(::core::primitive::u32),
				#[codec(index = 1)]
				Finalization,
				#[codec(index = 2)]
				Initialization,
			}
		}
		pub mod pallet_asset_conversion {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					create_pool {
						asset1: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
						asset2: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
					},
					#[codec(index = 1)]
					add_liquidity {
						asset1: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
						asset2: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
						amount1_desired: ::core::primitive::u128,
						amount2_desired: ::core::primitive::u128,
						amount1_min: ::core::primitive::u128,
						amount2_min: ::core::primitive::u128,
						mint_to: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 2)]
					remove_liquidity {
						asset1: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
						asset2: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
						lp_token_burn: ::core::primitive::u128,
						amount1_min_receive: ::core::primitive::u128,
						amount2_min_receive: ::core::primitive::u128,
						withdraw_to: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 3)]
					swap_exact_tokens_for_tokens {
						path: ::subxt::ext::subxt_core::alloc::boxed::Box<
							::subxt::ext::subxt_core::alloc::vec::Vec<
								runtime_types::staging_xcm::v5::location::Location,
							>,
						>,
						amount_in: ::core::primitive::u128,
						amount_out_min: ::core::primitive::u128,
						send_to: ::sp_core::crypto::AccountId32,
						keep_alive: ::core::primitive::bool,
					},
					#[codec(index = 4)]
					swap_tokens_for_exact_tokens {
						path: ::subxt::ext::subxt_core::alloc::boxed::Box<
							::subxt::ext::subxt_core::alloc::vec::Vec<
								runtime_types::staging_xcm::v5::location::Location,
							>,
						>,
						amount_out: ::core::primitive::u128,
						amount_in_max: ::core::primitive::u128,
						send_to: ::sp_core::crypto::AccountId32,
						keep_alive: ::core::primitive::bool,
					},
					#[codec(index = 5)]
					touch {
						asset1: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
						asset2: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidAssetPair,
					#[codec(index = 1)]
					PoolExists,
					#[codec(index = 2)]
					WrongDesiredAmount,
					#[codec(index = 3)]
					AmountOneLessThanMinimal,
					#[codec(index = 4)]
					AmountTwoLessThanMinimal,
					#[codec(index = 5)]
					ReserveLeftLessThanMinimal,
					#[codec(index = 6)]
					AmountOutTooHigh,
					#[codec(index = 7)]
					PoolNotFound,
					#[codec(index = 8)]
					Overflow,
					#[codec(index = 9)]
					AssetOneDepositDidNotMeetMinimum,
					#[codec(index = 10)]
					AssetTwoDepositDidNotMeetMinimum,
					#[codec(index = 11)]
					AssetOneWithdrawalDidNotMeetMinimum,
					#[codec(index = 12)]
					AssetTwoWithdrawalDidNotMeetMinimum,
					#[codec(index = 13)]
					OptimalAmountLessThanDesired,
					#[codec(index = 14)]
					InsufficientLiquidityMinted,
					#[codec(index = 15)]
					ZeroLiquidity,
					#[codec(index = 16)]
					ZeroAmount,
					#[codec(index = 17)]
					ProvidedMinimumNotSufficientForSwap,
					#[codec(index = 18)]
					ProvidedMaximumNotSufficientForSwap,
					#[codec(index = 19)]
					InvalidPath,
					#[codec(index = 20)]
					NonUniquePath,
					#[codec(index = 21)]
					IncorrectPoolAssetId,
					#[codec(index = 22)]
					BelowMinimum,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					PoolCreated {
						creator: ::sp_core::crypto::AccountId32,
						pool_id: (
							runtime_types::staging_xcm::v5::location::Location,
							runtime_types::staging_xcm::v5::location::Location,
						),
						pool_account: ::sp_core::crypto::AccountId32,
						lp_token: ::core::primitive::u32,
					},
					#[codec(index = 1)]
					LiquidityAdded {
						who: ::sp_core::crypto::AccountId32,
						mint_to: ::sp_core::crypto::AccountId32,
						pool_id: (
							runtime_types::staging_xcm::v5::location::Location,
							runtime_types::staging_xcm::v5::location::Location,
						),
						amount1_provided: ::core::primitive::u128,
						amount2_provided: ::core::primitive::u128,
						lp_token: ::core::primitive::u32,
						lp_token_minted: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					LiquidityRemoved {
						who: ::sp_core::crypto::AccountId32,
						withdraw_to: ::sp_core::crypto::AccountId32,
						pool_id: (
							runtime_types::staging_xcm::v5::location::Location,
							runtime_types::staging_xcm::v5::location::Location,
						),
						amount1: ::core::primitive::u128,
						amount2: ::core::primitive::u128,
						lp_token: ::core::primitive::u32,
						lp_token_burned: ::core::primitive::u128,
						withdrawal_fee: runtime_types::sp_arithmetic::per_things::Permill,
					},
					#[codec(index = 3)]
					SwapExecuted {
						who: ::sp_core::crypto::AccountId32,
						send_to: ::sp_core::crypto::AccountId32,
						amount_in: ::core::primitive::u128,
						amount_out: ::core::primitive::u128,
						path: ::subxt::ext::subxt_core::alloc::vec::Vec<(
							runtime_types::staging_xcm::v5::location::Location,
							::core::primitive::u128,
						)>,
					},
					#[codec(index = 4)]
					SwapCreditExecuted {
						amount_in: ::core::primitive::u128,
						amount_out: ::core::primitive::u128,
						path: ::subxt::ext::subxt_core::alloc::vec::Vec<(
							runtime_types::staging_xcm::v5::location::Location,
							::core::primitive::u128,
						)>,
					},
					#[codec(index = 5)]
					Touched {
						pool_id: (
							runtime_types::staging_xcm::v5::location::Location,
							runtime_types::staging_xcm::v5::location::Location,
						),
						who: ::sp_core::crypto::AccountId32,
					},
				}
			}
			pub mod types {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct PoolInfo<_0> {
					pub lp_token: _0,
				}
			}
		}
		pub mod pallet_asset_conversion_ops {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					migrate_to_new_account {
						asset1: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
						asset2: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidAssetPair,
					#[codec(index = 1)]
					PoolNotFound,
					#[codec(index = 2)]
					ZeroBalance,
					#[codec(index = 3)]
					PartialTransfer,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					MigratedToNewAccount {
						pool_id: (
							runtime_types::staging_xcm::v5::location::Location,
							runtime_types::staging_xcm::v5::location::Location,
						),
						prior_account: ::sp_core::crypto::AccountId32,
						new_account: ::sp_core::crypto::AccountId32,
					},
				}
			}
		}
		pub mod pallet_asset_conversion_tx_payment {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					AssetTxFeePaid {
						who: ::sp_core::crypto::AccountId32,
						actual_fee: ::core::primitive::u128,
						tip: ::core::primitive::u128,
						asset_id: runtime_types::staging_xcm::v5::location::Location,
					},
					#[codec(index = 1)]
					AssetRefundFailed { native_amount_kept: ::core::primitive::u128 },
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct ChargeAssetTxPayment {
				#[codec(compact)]
				pub tip: ::core::primitive::u128,
				pub asset_id:
					::core::option::Option<runtime_types::staging_xcm::v5::location::Location>,
			}
		}
		pub mod pallet_asset_rewards {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					create_pool {
						staked_asset_id: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
						reward_asset_id: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::location::Location,
						>,
						reward_rate_per_block: ::core::primitive::u128,
						expiry: runtime_types::frame_support::traits::schedule::DispatchTime<
							::core::primitive::u32,
						>,
						admin: ::core::option::Option<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 1)]
					stake { pool_id: ::core::primitive::u32, amount: ::core::primitive::u128 },
					#[codec(index = 2)]
					unstake {
						pool_id: ::core::primitive::u32,
						amount: ::core::primitive::u128,
						staker: ::core::option::Option<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 3)]
					harvest_rewards {
						pool_id: ::core::primitive::u32,
						staker: ::core::option::Option<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 4)]
					set_pool_reward_rate_per_block {
						pool_id: ::core::primitive::u32,
						new_reward_rate_per_block: ::core::primitive::u128,
					},
					#[codec(index = 5)]
					set_pool_admin {
						pool_id: ::core::primitive::u32,
						new_admin: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 6)]
					set_pool_expiry_block {
						pool_id: ::core::primitive::u32,
						new_expiry: runtime_types::frame_support::traits::schedule::DispatchTime<
							::core::primitive::u32,
						>,
					},
					#[codec(index = 7)]
					deposit_reward_tokens {
						pool_id: ::core::primitive::u32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 8)]
					cleanup_pool { pool_id: ::core::primitive::u32 },
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					NotEnoughTokens,
					#[codec(index = 1)]
					NonExistentPool,
					#[codec(index = 2)]
					NonExistentStaker,
					#[codec(index = 3)]
					NonExistentAsset,
					#[codec(index = 4)]
					BlockNumberConversionError,
					#[codec(index = 5)]
					ExpiryBlockMustBeInTheFuture,
					#[codec(index = 6)]
					InsufficientFunds,
					#[codec(index = 7)]
					ExpiryCut,
					#[codec(index = 8)]
					RewardRateCut,
					#[codec(index = 9)]
					NonEmptyPool,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Staked {
						staker: ::sp_core::crypto::AccountId32,
						pool_id: ::core::primitive::u32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					Unstaked {
						caller: ::sp_core::crypto::AccountId32,
						staker: ::sp_core::crypto::AccountId32,
						pool_id: ::core::primitive::u32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					RewardsHarvested {
						caller: ::sp_core::crypto::AccountId32,
						staker: ::sp_core::crypto::AccountId32,
						pool_id: ::core::primitive::u32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					PoolCreated {
						creator: ::sp_core::crypto::AccountId32,
						pool_id: ::core::primitive::u32,
						staked_asset_id: runtime_types::staging_xcm::v5::location::Location,
						reward_asset_id: runtime_types::staging_xcm::v5::location::Location,
						reward_rate_per_block: ::core::primitive::u128,
						expiry_block: ::core::primitive::u32,
						admin: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 4)]
					PoolRewardRateModified {
						pool_id: ::core::primitive::u32,
						new_reward_rate_per_block: ::core::primitive::u128,
					},
					#[codec(index = 5)]
					PoolAdminModified {
						pool_id: ::core::primitive::u32,
						new_admin: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 6)]
					PoolExpiryBlockModified {
						pool_id: ::core::primitive::u32,
						new_expiry_block: ::core::primitive::u32,
					},
					#[codec(index = 7)]
					PoolCleanedUp { pool_id: ::core::primitive::u32 },
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum FreezeReason {
					#[codec(index = 0)]
					Staked,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum HoldReason {
					#[codec(index = 0)]
					PoolCreation,
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct PoolInfo<_0, _1, _2, _3> {
				pub staked_asset_id: _1,
				pub reward_asset_id: _1,
				pub reward_rate_per_block: _2,
				pub expiry_block: _3,
				pub admin: _0,
				pub total_tokens_staked: _2,
				pub reward_per_token_stored: _2,
				pub last_update_block: _3,
				pub account: _0,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct PoolStakerInfo<_0> {
				pub amount: _0,
				pub rewards: _0,
				pub reward_per_token_paid: _0,
			}
		}
		pub mod pallet_assets {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call1 {
					#[codec(index = 0)]
					create {
						#[codec(compact)]
						id: ::core::primitive::u32,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						min_balance: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					force_create {
						#[codec(compact)]
						id: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						is_sufficient: ::core::primitive::bool,
						#[codec(compact)]
						min_balance: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					start_destroy {
						#[codec(compact)]
						id: ::core::primitive::u32,
					},
					#[codec(index = 3)]
					destroy_accounts {
						#[codec(compact)]
						id: ::core::primitive::u32,
					},
					#[codec(index = 4)]
					destroy_approvals {
						#[codec(compact)]
						id: ::core::primitive::u32,
					},
					#[codec(index = 5)]
					finish_destroy {
						#[codec(compact)]
						id: ::core::primitive::u32,
					},
					#[codec(index = 6)]
					mint {
						#[codec(compact)]
						id: ::core::primitive::u32,
						beneficiary: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 7)]
					burn {
						#[codec(compact)]
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 8)]
					transfer {
						#[codec(compact)]
						id: ::core::primitive::u32,
						target: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					transfer_keep_alive {
						#[codec(compact)]
						id: ::core::primitive::u32,
						target: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 10)]
					force_transfer {
						#[codec(compact)]
						id: ::core::primitive::u32,
						source: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 11)]
					freeze {
						#[codec(compact)]
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 12)]
					thaw {
						#[codec(compact)]
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 13)]
					freeze_asset {
						#[codec(compact)]
						id: ::core::primitive::u32,
					},
					#[codec(index = 14)]
					thaw_asset {
						#[codec(compact)]
						id: ::core::primitive::u32,
					},
					#[codec(index = 15)]
					transfer_ownership {
						#[codec(compact)]
						id: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 16)]
					set_team {
						#[codec(compact)]
						id: ::core::primitive::u32,
						issuer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						freezer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 17)]
					set_metadata {
						#[codec(compact)]
						id: ::core::primitive::u32,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						symbol: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						decimals: ::core::primitive::u8,
					},
					#[codec(index = 18)]
					clear_metadata {
						#[codec(compact)]
						id: ::core::primitive::u32,
					},
					#[codec(index = 19)]
					force_set_metadata {
						#[codec(compact)]
						id: ::core::primitive::u32,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						symbol: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						decimals: ::core::primitive::u8,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 20)]
					force_clear_metadata {
						#[codec(compact)]
						id: ::core::primitive::u32,
					},
					#[codec(index = 21)]
					force_asset_status {
						#[codec(compact)]
						id: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						issuer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						freezer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						min_balance: ::core::primitive::u128,
						is_sufficient: ::core::primitive::bool,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 22)]
					approve_transfer {
						#[codec(compact)]
						id: ::core::primitive::u32,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 23)]
					cancel_approval {
						#[codec(compact)]
						id: ::core::primitive::u32,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 24)]
					force_cancel_approval {
						#[codec(compact)]
						id: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 25)]
					transfer_approved {
						#[codec(compact)]
						id: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						destination: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 26)]
					touch {
						#[codec(compact)]
						id: ::core::primitive::u32,
					},
					#[codec(index = 27)]
					refund {
						#[codec(compact)]
						id: ::core::primitive::u32,
						allow_burn: ::core::primitive::bool,
					},
					#[codec(index = 28)]
					set_min_balance {
						#[codec(compact)]
						id: ::core::primitive::u32,
						min_balance: ::core::primitive::u128,
					},
					#[codec(index = 29)]
					touch_other {
						#[codec(compact)]
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 30)]
					refund_other {
						#[codec(compact)]
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 31)]
					block {
						#[codec(compact)]
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 32)]
					transfer_all {
						#[codec(compact)]
						id: ::core::primitive::u32,
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						keep_alive: ::core::primitive::bool,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call2 {
					#[codec(index = 0)]
					create {
						id: runtime_types::staging_xcm::v5::location::Location,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						min_balance: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					force_create {
						id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						is_sufficient: ::core::primitive::bool,
						#[codec(compact)]
						min_balance: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					start_destroy { id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 3)]
					destroy_accounts { id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 4)]
					destroy_approvals { id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 5)]
					finish_destroy { id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 6)]
					mint {
						id: runtime_types::staging_xcm::v5::location::Location,
						beneficiary: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 7)]
					burn {
						id: runtime_types::staging_xcm::v5::location::Location,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 8)]
					transfer {
						id: runtime_types::staging_xcm::v5::location::Location,
						target: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					transfer_keep_alive {
						id: runtime_types::staging_xcm::v5::location::Location,
						target: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 10)]
					force_transfer {
						id: runtime_types::staging_xcm::v5::location::Location,
						source: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 11)]
					freeze {
						id: runtime_types::staging_xcm::v5::location::Location,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 12)]
					thaw {
						id: runtime_types::staging_xcm::v5::location::Location,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 13)]
					freeze_asset { id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 14)]
					thaw_asset { id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 15)]
					transfer_ownership {
						id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 16)]
					set_team {
						id: runtime_types::staging_xcm::v5::location::Location,
						issuer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						freezer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 17)]
					set_metadata {
						id: runtime_types::staging_xcm::v5::location::Location,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						symbol: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						decimals: ::core::primitive::u8,
					},
					#[codec(index = 18)]
					clear_metadata { id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 19)]
					force_set_metadata {
						id: runtime_types::staging_xcm::v5::location::Location,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						symbol: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						decimals: ::core::primitive::u8,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 20)]
					force_clear_metadata { id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 21)]
					force_asset_status {
						id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						issuer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						freezer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						min_balance: ::core::primitive::u128,
						is_sufficient: ::core::primitive::bool,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 22)]
					approve_transfer {
						id: runtime_types::staging_xcm::v5::location::Location,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 23)]
					cancel_approval {
						id: runtime_types::staging_xcm::v5::location::Location,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 24)]
					force_cancel_approval {
						id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 25)]
					transfer_approved {
						id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						destination: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 26)]
					touch { id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 27)]
					refund {
						id: runtime_types::staging_xcm::v5::location::Location,
						allow_burn: ::core::primitive::bool,
					},
					#[codec(index = 28)]
					set_min_balance {
						id: runtime_types::staging_xcm::v5::location::Location,
						min_balance: ::core::primitive::u128,
					},
					#[codec(index = 29)]
					touch_other {
						id: runtime_types::staging_xcm::v5::location::Location,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 30)]
					refund_other {
						id: runtime_types::staging_xcm::v5::location::Location,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 31)]
					block {
						id: runtime_types::staging_xcm::v5::location::Location,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 32)]
					transfer_all {
						id: runtime_types::staging_xcm::v5::location::Location,
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						keep_alive: ::core::primitive::bool,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call3 {
					#[codec(index = 0)]
					create {
						id: ::core::primitive::u32,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						min_balance: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					force_create {
						id: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						is_sufficient: ::core::primitive::bool,
						#[codec(compact)]
						min_balance: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					start_destroy { id: ::core::primitive::u32 },
					#[codec(index = 3)]
					destroy_accounts { id: ::core::primitive::u32 },
					#[codec(index = 4)]
					destroy_approvals { id: ::core::primitive::u32 },
					#[codec(index = 5)]
					finish_destroy { id: ::core::primitive::u32 },
					#[codec(index = 6)]
					mint {
						id: ::core::primitive::u32,
						beneficiary: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 7)]
					burn {
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 8)]
					transfer {
						id: ::core::primitive::u32,
						target: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					transfer_keep_alive {
						id: ::core::primitive::u32,
						target: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 10)]
					force_transfer {
						id: ::core::primitive::u32,
						source: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 11)]
					freeze {
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 12)]
					thaw {
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 13)]
					freeze_asset { id: ::core::primitive::u32 },
					#[codec(index = 14)]
					thaw_asset { id: ::core::primitive::u32 },
					#[codec(index = 15)]
					transfer_ownership {
						id: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 16)]
					set_team {
						id: ::core::primitive::u32,
						issuer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						freezer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 17)]
					set_metadata {
						id: ::core::primitive::u32,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						symbol: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						decimals: ::core::primitive::u8,
					},
					#[codec(index = 18)]
					clear_metadata { id: ::core::primitive::u32 },
					#[codec(index = 19)]
					force_set_metadata {
						id: ::core::primitive::u32,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						symbol: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						decimals: ::core::primitive::u8,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 20)]
					force_clear_metadata { id: ::core::primitive::u32 },
					#[codec(index = 21)]
					force_asset_status {
						id: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						issuer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						freezer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						min_balance: ::core::primitive::u128,
						is_sufficient: ::core::primitive::bool,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 22)]
					approve_transfer {
						id: ::core::primitive::u32,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 23)]
					cancel_approval {
						id: ::core::primitive::u32,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 24)]
					force_cancel_approval {
						id: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 25)]
					transfer_approved {
						id: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						destination: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						amount: ::core::primitive::u128,
					},
					#[codec(index = 26)]
					touch { id: ::core::primitive::u32 },
					#[codec(index = 27)]
					refund { id: ::core::primitive::u32, allow_burn: ::core::primitive::bool },
					#[codec(index = 28)]
					set_min_balance {
						id: ::core::primitive::u32,
						min_balance: ::core::primitive::u128,
					},
					#[codec(index = 29)]
					touch_other {
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 30)]
					refund_other {
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 31)]
					block {
						id: ::core::primitive::u32,
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 32)]
					transfer_all {
						id: ::core::primitive::u32,
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						keep_alive: ::core::primitive::bool,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					BalanceLow,
					#[codec(index = 1)]
					NoAccount,
					#[codec(index = 2)]
					NoPermission,
					#[codec(index = 3)]
					Unknown,
					#[codec(index = 4)]
					Frozen,
					#[codec(index = 5)]
					InUse,
					#[codec(index = 6)]
					BadWitness,
					#[codec(index = 7)]
					MinBalanceZero,
					#[codec(index = 8)]
					UnavailableConsumer,
					#[codec(index = 9)]
					BadMetadata,
					#[codec(index = 10)]
					Unapproved,
					#[codec(index = 11)]
					WouldDie,
					#[codec(index = 12)]
					AlreadyExists,
					#[codec(index = 13)]
					NoDeposit,
					#[codec(index = 14)]
					WouldBurn,
					#[codec(index = 15)]
					LiveAsset,
					#[codec(index = 16)]
					AssetNotLive,
					#[codec(index = 17)]
					IncorrectStatus,
					#[codec(index = 18)]
					NotFrozen,
					#[codec(index = 19)]
					CallbackFailed,
					#[codec(index = 20)]
					BadAssetId,
					#[codec(index = 21)]
					ContainsFreezes,
					#[codec(index = 22)]
					ContainsHolds,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event1 {
					#[codec(index = 0)]
					Created {
						asset_id: ::core::primitive::u32,
						creator: ::sp_core::crypto::AccountId32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 1)]
					Issued {
						asset_id: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					Transferred {
						asset_id: ::core::primitive::u32,
						from: ::sp_core::crypto::AccountId32,
						to: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					Burned {
						asset_id: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
						balance: ::core::primitive::u128,
					},
					#[codec(index = 4)]
					TeamChanged {
						asset_id: ::core::primitive::u32,
						issuer: ::sp_core::crypto::AccountId32,
						admin: ::sp_core::crypto::AccountId32,
						freezer: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 5)]
					OwnerChanged {
						asset_id: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 6)]
					Frozen { asset_id: ::core::primitive::u32, who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 7)]
					Thawed { asset_id: ::core::primitive::u32, who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 8)]
					AssetFrozen { asset_id: ::core::primitive::u32 },
					#[codec(index = 9)]
					AssetThawed { asset_id: ::core::primitive::u32 },
					#[codec(index = 10)]
					AccountsDestroyed {
						asset_id: ::core::primitive::u32,
						accounts_destroyed: ::core::primitive::u32,
						accounts_remaining: ::core::primitive::u32,
					},
					#[codec(index = 11)]
					ApprovalsDestroyed {
						asset_id: ::core::primitive::u32,
						approvals_destroyed: ::core::primitive::u32,
						approvals_remaining: ::core::primitive::u32,
					},
					#[codec(index = 12)]
					DestructionStarted { asset_id: ::core::primitive::u32 },
					#[codec(index = 13)]
					Destroyed { asset_id: ::core::primitive::u32 },
					#[codec(index = 14)]
					ForceCreated {
						asset_id: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 15)]
					MetadataSet {
						asset_id: ::core::primitive::u32,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						symbol: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						decimals: ::core::primitive::u8,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					MetadataCleared { asset_id: ::core::primitive::u32 },
					#[codec(index = 17)]
					ApprovedTransfer {
						asset_id: ::core::primitive::u32,
						source: ::sp_core::crypto::AccountId32,
						delegate: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 18)]
					ApprovalCancelled {
						asset_id: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
						delegate: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 19)]
					TransferredApproved {
						asset_id: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
						delegate: ::sp_core::crypto::AccountId32,
						destination: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 20)]
					AssetStatusChanged { asset_id: ::core::primitive::u32 },
					#[codec(index = 21)]
					AssetMinBalanceChanged {
						asset_id: ::core::primitive::u32,
						new_min_balance: ::core::primitive::u128,
					},
					#[codec(index = 22)]
					Touched {
						asset_id: ::core::primitive::u32,
						who: ::sp_core::crypto::AccountId32,
						depositor: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 23)]
					Blocked {
						asset_id: ::core::primitive::u32,
						who: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 24)]
					Deposited {
						asset_id: ::core::primitive::u32,
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 25)]
					Withdrawn {
						asset_id: ::core::primitive::u32,
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event2 {
					#[codec(index = 0)]
					Created {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						creator: ::sp_core::crypto::AccountId32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 1)]
					Issued {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					Transferred {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						from: ::sp_core::crypto::AccountId32,
						to: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					Burned {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::sp_core::crypto::AccountId32,
						balance: ::core::primitive::u128,
					},
					#[codec(index = 4)]
					TeamChanged {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						issuer: ::sp_core::crypto::AccountId32,
						admin: ::sp_core::crypto::AccountId32,
						freezer: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 5)]
					OwnerChanged {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 6)]
					Frozen {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						who: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 7)]
					Thawed {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						who: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 8)]
					AssetFrozen { asset_id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 9)]
					AssetThawed { asset_id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 10)]
					AccountsDestroyed {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						accounts_destroyed: ::core::primitive::u32,
						accounts_remaining: ::core::primitive::u32,
					},
					#[codec(index = 11)]
					ApprovalsDestroyed {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						approvals_destroyed: ::core::primitive::u32,
						approvals_remaining: ::core::primitive::u32,
					},
					#[codec(index = 12)]
					DestructionStarted {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
					},
					#[codec(index = 13)]
					Destroyed { asset_id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 14)]
					ForceCreated {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 15)]
					MetadataSet {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						symbol: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						decimals: ::core::primitive::u8,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					MetadataCleared { asset_id: runtime_types::staging_xcm::v5::location::Location },
					#[codec(index = 17)]
					ApprovedTransfer {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						source: ::sp_core::crypto::AccountId32,
						delegate: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 18)]
					ApprovalCancelled {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::sp_core::crypto::AccountId32,
						delegate: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 19)]
					TransferredApproved {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						owner: ::sp_core::crypto::AccountId32,
						delegate: ::sp_core::crypto::AccountId32,
						destination: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 20)]
					AssetStatusChanged {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
					},
					#[codec(index = 21)]
					AssetMinBalanceChanged {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						new_min_balance: ::core::primitive::u128,
					},
					#[codec(index = 22)]
					Touched {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						who: ::sp_core::crypto::AccountId32,
						depositor: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 23)]
					Blocked {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						who: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 24)]
					Deposited {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 25)]
					Withdrawn {
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
				}
			}
			pub mod types {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum AccountStatus {
					#[codec(index = 0)]
					Liquid,
					#[codec(index = 1)]
					Frozen,
					#[codec(index = 2)]
					Blocked,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct Approval<_0, _1> {
					pub amount: _0,
					pub deposit: _1,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct AssetAccount<_0, _1, _2, _3> {
					pub balance: _0,
					pub status: runtime_types::pallet_assets::types::AccountStatus,
					pub reason: runtime_types::pallet_assets::types::ExistenceReason<_0, _3>,
					pub extra: _2,
					#[codec(skip)]
					pub __ignore: ::core::marker::PhantomData<_1>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct AssetDetails<_0, _1, _2> {
					pub owner: _1,
					pub issuer: _1,
					pub admin: _1,
					pub freezer: _1,
					pub supply: _0,
					pub deposit: _2,
					pub min_balance: _0,
					pub is_sufficient: ::core::primitive::bool,
					pub accounts: ::core::primitive::u32,
					pub sufficients: ::core::primitive::u32,
					pub approvals: ::core::primitive::u32,
					pub status: runtime_types::pallet_assets::types::AssetStatus,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct AssetMetadata<_0, _1> {
					pub deposit: _0,
					pub name: _1,
					pub symbol: _1,
					pub decimals: ::core::primitive::u8,
					pub is_frozen: ::core::primitive::bool,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum AssetStatus {
					#[codec(index = 0)]
					Live,
					#[codec(index = 1)]
					Frozen,
					#[codec(index = 2)]
					Destroying,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum ExistenceReason<_0, _1> {
					#[codec(index = 0)]
					Consumer,
					#[codec(index = 1)]
					Sufficient,
					#[codec(index = 2)]
					DepositHeld(_0),
					#[codec(index = 3)]
					DepositRefunded,
					#[codec(index = 4)]
					DepositFrom(_1, _0),
				}
			}
		}
		pub mod pallet_assets_freezer {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					TooManyFreezes,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event1 {
					#[codec(index = 0)]
					Frozen {
						who: ::sp_core::crypto::AccountId32,
						asset_id: ::core::primitive::u32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					Thawed {
						who: ::sp_core::crypto::AccountId32,
						asset_id: ::core::primitive::u32,
						amount: ::core::primitive::u128,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event2 {
					#[codec(index = 0)]
					Frozen {
						who: ::sp_core::crypto::AccountId32,
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					Thawed {
						who: ::sp_core::crypto::AccountId32,
						asset_id: runtime_types::staging_xcm::v5::location::Location,
						amount: ::core::primitive::u128,
					},
				}
			}
		}
		pub mod pallet_balances {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					transfer_allow_death {
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						value: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					force_transfer {
						source: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						value: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					transfer_keep_alive {
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						value: ::core::primitive::u128,
					},
					#[codec(index = 4)]
					transfer_all {
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						keep_alive: ::core::primitive::bool,
					},
					#[codec(index = 5)]
					force_unreserve {
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 6)]
					upgrade_accounts {
						who: ::subxt::ext::subxt_core::alloc::vec::Vec<
							::sp_core::crypto::AccountId32,
						>,
					},
					#[codec(index = 8)]
					force_set_balance {
						who: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						#[codec(compact)]
						new_free: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					force_adjust_total_issuance {
						direction: runtime_types::pallet_balances::types::AdjustmentDirection,
						#[codec(compact)]
						delta: ::core::primitive::u128,
					},
					#[codec(index = 10)]
					burn {
						#[codec(compact)]
						value: ::core::primitive::u128,
						keep_alive: ::core::primitive::bool,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					VestingBalance,
					#[codec(index = 1)]
					LiquidityRestrictions,
					#[codec(index = 2)]
					InsufficientBalance,
					#[codec(index = 3)]
					ExistentialDeposit,
					#[codec(index = 4)]
					Expendability,
					#[codec(index = 5)]
					ExistingVestingSchedule,
					#[codec(index = 6)]
					DeadAccount,
					#[codec(index = 7)]
					TooManyReserves,
					#[codec(index = 8)]
					TooManyHolds,
					#[codec(index = 9)]
					TooManyFreezes,
					#[codec(index = 10)]
					IssuanceDeactivated,
					#[codec(index = 11)]
					DeltaZero,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Endowed {
						account: ::sp_core::crypto::AccountId32,
						free_balance: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					DustLost {
						account: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					Transfer {
						from: ::sp_core::crypto::AccountId32,
						to: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					BalanceSet {
						who: ::sp_core::crypto::AccountId32,
						free: ::core::primitive::u128,
					},
					#[codec(index = 4)]
					Reserved {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 5)]
					Unreserved {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 6)]
					ReserveRepatriated {
						from: ::sp_core::crypto::AccountId32,
						to: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
						destination_status:
							runtime_types::frame_support::traits::tokens::misc::BalanceStatus,
					},
					#[codec(index = 7)]
					Deposit { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 8)]
					Withdraw {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					Slashed { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 10)]
					Minted { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 11)]
					Burned { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 12)]
					Suspended {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 13)]
					Restored {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 14)]
					Upgraded { who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 15)]
					Issued { amount: ::core::primitive::u128 },
					#[codec(index = 16)]
					Rescinded { amount: ::core::primitive::u128 },
					#[codec(index = 17)]
					Locked { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 18)]
					Unlocked {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 19)]
					Frozen { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 20)]
					Thawed { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 21)]
					TotalIssuanceForced {
						old: ::core::primitive::u128,
						new: ::core::primitive::u128,
					},
				}
			}
			pub mod types {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct AccountData<_0> {
					pub free: _0,
					pub reserved: _0,
					pub frozen: _0,
					pub flags: runtime_types::pallet_balances::types::ExtraFlags,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum AdjustmentDirection {
					#[codec(index = 0)]
					Increase,
					#[codec(index = 1)]
					Decrease,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct BalanceLock<_0> {
					pub id: [::core::primitive::u8; 8usize],
					pub amount: _0,
					pub reasons: runtime_types::pallet_balances::types::Reasons,
				}
				#[derive(
					::codec::Decode,
					::codec::Encode,
					::subxt::ext::subxt_core::ext::codec::CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct ExtraFlags(pub ::core::primitive::u128);
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Reasons {
					#[codec(index = 0)]
					Fee,
					#[codec(index = 1)]
					Misc,
					#[codec(index = 2)]
					All,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct ReserveData<_0, _1> {
					pub id: _0,
					pub amount: _1,
				}
			}
		}
		pub mod pallet_bridge_messages {
			use super::runtime_types;
			pub mod lanes_manager {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum LanesManagerError {
					#[codec(index = 0)]
					InboundLaneAlreadyExists,
					#[codec(index = 1)]
					OutboundLaneAlreadyExists,
					#[codec(index = 2)]
					UnknownInboundLane,
					#[codec(index = 3)]
					UnknownOutboundLane,
					#[codec(index = 4)]
					ClosedInboundLane,
					#[codec(index = 5)]
					ClosedOutboundLane,
					#[codec(index = 6)]
					LaneDispatcherInactive,
				}
			}
			pub mod outbound_lane {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum ReceptionConfirmationError {
					#[codec(index = 0)]
					FailedToConfirmFutureMessages,
					#[codec(index = 1)]
					EmptyUnrewardedRelayerEntry,
					#[codec(index = 2)]
					NonConsecutiveUnrewardedRelayerEntries,
					#[codec(index = 3)]
					TryingToConfirmMoreMessagesThanExpected,
				}
			}
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set_owner { new_owner: ::core::option::Option<::sp_core::crypto::AccountId32> },
					#[codec(index = 1)]
					set_operating_mode {
						operating_mode: runtime_types::bp_messages::MessagesOperatingMode,
					},
					#[codec(index = 2)]
					receive_messages_proof {
						relayer_id_at_bridged_chain: ::sp_core::crypto::AccountId32,
						proof: ::subxt::ext::subxt_core::alloc::boxed::Box<
							::bp_messages::target_chain::FromBridgedChainMessagesProof<
								::subxt::ext::subxt_core::utils::H256,
								runtime_types::bp_messages::lane::HashedLaneId,
							>,
						>,
						messages_count: ::core::primitive::u32,
						dispatch_weight: ::sp_weights::Weight,
					},
					#[codec(index = 3)]
					receive_messages_delivery_proof {
						proof: ::bp_messages::source_chain::FromBridgedChainMessagesDeliveryProof<
							::subxt::ext::subxt_core::utils::H256,
							runtime_types::bp_messages::lane::HashedLaneId,
						>,
						relayers_state: ::bp_messages::UnrewardedRelayersState,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
                    NotOperatingNormally,
                    #[codec(index = 1)]
                    LanesManager(
                        runtime_types::pallet_bridge_messages::lanes_manager::LanesManagerError,
                    ),
                    #[codec(index = 2)]
                    MessageRejectedByPallet(
                        runtime_types::bp_messages::VerificationError,
                    ),
                    #[codec(index = 3)]
                    TooManyMessagesInTheProof,
                    #[codec(index = 4)]
                    InvalidMessagesProof,
                    #[codec(index = 5)]
                    InvalidMessagesDeliveryProof,
                    #[codec(index = 6)]
                    InvalidUnrewardedRelayersState,
                    #[codec(index = 7)]
                    InsufficientDispatchWeight,
                    #[codec(index = 8)]
                    ReceptionConfirmation(
                        runtime_types::pallet_bridge_messages::outbound_lane::ReceptionConfirmationError,
                    ),
                    #[codec(index = 9)]
                    BridgeModule(runtime_types::bp_runtime::OwnedBridgeModuleError),
                }
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
                    MessageAccepted {
                        lane_id: runtime_types::bp_messages::lane::HashedLaneId,
                        nonce: ::core::primitive::u64,
                    },
                    #[codec(index = 1)]
                    MessagesReceived(
                        runtime_types::bp_messages::ReceivedMessages<
                            runtime_types::pallet_xcm_bridge::dispatcher::XcmBlobMessageDispatchResult,
                            runtime_types::bp_messages::lane::HashedLaneId,
                        >,
                    ),
                    #[codec(index = 2)]
                    MessagesDelivered {
                        lane_id: runtime_types::bp_messages::lane::HashedLaneId,
                        messages: runtime_types::bp_messages::DeliveredMessages,
                    },
                }
			}
		}
		pub mod pallet_bridge_relayers {
			use super::runtime_types;
			pub mod extension {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct BridgeRelayersTransactionExtension;
			}
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					claim_rewards {
						rewards_account_params: runtime_types::bp_relayers::RewardsAccountParams<
							runtime_types::bp_messages::lane::HashedLaneId,
						>,
					},
					#[codec(index = 1)]
					register { valid_till: ::core::primitive::u32 },
					#[codec(index = 2)]
					deregister,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					NoRewardForRelayer,
					#[codec(index = 1)]
					FailedToPayReward,
					#[codec(index = 2)]
					InvalidRegistrationLease,
					#[codec(index = 3)]
					CannotReduceRegistrationLease,
					#[codec(index = 4)]
					FailedToReserve,
					#[codec(index = 5)]
					FailedToUnreserve,
					#[codec(index = 6)]
					NotRegistered,
					#[codec(index = 7)]
					RegistrationIsStillActive,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					RewardRegistered {
						relayer: ::sp_core::crypto::AccountId32,
						rewards_account_params: runtime_types::bp_relayers::RewardsAccountParams<
							runtime_types::bp_messages::lane::HashedLaneId,
						>,
						reward: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					RewardPaid {
						relayer: ::sp_core::crypto::AccountId32,
						rewards_account_params: runtime_types::bp_relayers::RewardsAccountParams<
							runtime_types::bp_messages::lane::HashedLaneId,
						>,
						reward: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					RegistrationUpdated {
						relayer: ::sp_core::crypto::AccountId32,
						registration: runtime_types::bp_relayers::registration::Registration<
							::core::primitive::u32,
							::core::primitive::u128,
						>,
					},
					#[codec(index = 3)]
					Deregistered { relayer: ::sp_core::crypto::AccountId32 },
					#[codec(index = 4)]
					SlashedAndDeregistered {
						relayer: ::sp_core::crypto::AccountId32,
						registration: runtime_types::bp_relayers::registration::Registration<
							::core::primitive::u32,
							::core::primitive::u128,
						>,
					},
				}
			}
		}
		pub mod pallet_collator_selection {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set_invulnerables {
						new: ::subxt::ext::subxt_core::alloc::vec::Vec<
							::sp_core::crypto::AccountId32,
						>,
					},
					#[codec(index = 1)]
					set_desired_candidates { max: ::core::primitive::u32 },
					#[codec(index = 2)]
					set_candidacy_bond { bond: ::core::primitive::u128 },
					#[codec(index = 3)]
					register_as_candidate,
					#[codec(index = 4)]
					leave_intent,
					#[codec(index = 5)]
					add_invulnerable { who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 6)]
					remove_invulnerable { who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 7)]
					update_bond { new_deposit: ::core::primitive::u128 },
					#[codec(index = 8)]
					take_candidate_slot {
						deposit: ::core::primitive::u128,
						target: ::sp_core::crypto::AccountId32,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct CandidateInfo<_0, _1> {
					pub who: _0,
					pub deposit: _1,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					TooManyCandidates,
					#[codec(index = 1)]
					TooFewEligibleCollators,
					#[codec(index = 2)]
					AlreadyCandidate,
					#[codec(index = 3)]
					NotCandidate,
					#[codec(index = 4)]
					TooManyInvulnerables,
					#[codec(index = 5)]
					AlreadyInvulnerable,
					#[codec(index = 6)]
					NotInvulnerable,
					#[codec(index = 7)]
					NoAssociatedValidatorId,
					#[codec(index = 8)]
					ValidatorNotRegistered,
					#[codec(index = 9)]
					InsertToCandidateListFailed,
					#[codec(index = 10)]
					RemoveFromCandidateListFailed,
					#[codec(index = 11)]
					DepositTooLow,
					#[codec(index = 12)]
					UpdateCandidateListFailed,
					#[codec(index = 13)]
					InsufficientBond,
					#[codec(index = 14)]
					TargetIsNotCandidate,
					#[codec(index = 15)]
					IdenticalDeposit,
					#[codec(index = 16)]
					InvalidUnreserve,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NewInvulnerables {
						invulnerables: ::subxt::ext::subxt_core::alloc::vec::Vec<
							::sp_core::crypto::AccountId32,
						>,
					},
					#[codec(index = 1)]
					InvulnerableAdded { account_id: ::sp_core::crypto::AccountId32 },
					#[codec(index = 2)]
					InvulnerableRemoved { account_id: ::sp_core::crypto::AccountId32 },
					#[codec(index = 3)]
					NewDesiredCandidates { desired_candidates: ::core::primitive::u32 },
					#[codec(index = 4)]
					NewCandidacyBond { bond_amount: ::core::primitive::u128 },
					#[codec(index = 5)]
					CandidateAdded {
						account_id: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
					#[codec(index = 6)]
					CandidateBondUpdated {
						account_id: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
					#[codec(index = 7)]
					CandidateRemoved { account_id: ::sp_core::crypto::AccountId32 },
					#[codec(index = 8)]
					CandidateReplaced {
						old: ::sp_core::crypto::AccountId32,
						new: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					InvalidInvulnerableSkipped { account_id: ::sp_core::crypto::AccountId32 },
				}
			}
		}
		pub mod pallet_message_queue {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					reap_page {
						message_origin:
							runtime_types::cumulus_primitives_core::AggregateMessageOrigin,
						page_index: ::core::primitive::u32,
					},
					#[codec(index = 1)]
					execute_overweight {
						message_origin:
							runtime_types::cumulus_primitives_core::AggregateMessageOrigin,
						page: ::core::primitive::u32,
						index: ::core::primitive::u32,
						weight_limit: ::sp_weights::Weight,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					NotReapable,
					#[codec(index = 1)]
					NoPage,
					#[codec(index = 2)]
					NoMessage,
					#[codec(index = 3)]
					AlreadyProcessed,
					#[codec(index = 4)]
					Queued,
					#[codec(index = 5)]
					InsufficientWeight,
					#[codec(index = 6)]
					TemporarilyUnprocessable,
					#[codec(index = 7)]
					QueuePaused,
					#[codec(index = 8)]
					RecursiveDisallowed,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ProcessingFailed {
						id: ::subxt::ext::subxt_core::utils::H256,
						origin: runtime_types::cumulus_primitives_core::AggregateMessageOrigin,
						error: runtime_types::frame_support::traits::messages::ProcessMessageError,
					},
					#[codec(index = 1)]
					Processed {
						id: ::subxt::ext::subxt_core::utils::H256,
						origin: runtime_types::cumulus_primitives_core::AggregateMessageOrigin,
						weight_used: ::sp_weights::Weight,
						success: ::core::primitive::bool,
					},
					#[codec(index = 2)]
					OverweightEnqueued {
						id: [::core::primitive::u8; 32usize],
						origin: runtime_types::cumulus_primitives_core::AggregateMessageOrigin,
						page_index: ::core::primitive::u32,
						message_index: ::core::primitive::u32,
					},
					#[codec(index = 3)]
					PageReaped {
						origin: runtime_types::cumulus_primitives_core::AggregateMessageOrigin,
						index: ::core::primitive::u32,
					},
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct BookState<_0> {
				pub begin: ::core::primitive::u32,
				pub end: ::core::primitive::u32,
				pub count: ::core::primitive::u32,
				pub ready_neighbours:
					::core::option::Option<runtime_types::pallet_message_queue::Neighbours<_0>>,
				pub message_count: ::core::primitive::u64,
				pub size: ::core::primitive::u64,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct Neighbours<_0> {
				pub prev: _0,
				pub next: _0,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct Page<_0> {
				pub remaining: _0,
				pub remaining_size: _0,
				pub first_index: _0,
				pub first: _0,
				pub last: _0,
				pub heap: runtime_types::bounded_collections::bounded_vec::BoundedVec<
					::core::primitive::u8,
				>,
			}
		}
		pub mod pallet_multisig {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					as_multi_threshold_1 {
						other_signatories: ::subxt::ext::subxt_core::alloc::vec::Vec<
							::sp_core::crypto::AccountId32,
						>,
						call: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 1)]
					as_multi {
						threshold: ::core::primitive::u16,
						other_signatories: ::subxt::ext::subxt_core::alloc::vec::Vec<
							::sp_core::crypto::AccountId32,
						>,
						maybe_timepoint: ::core::option::Option<
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						>,
						call: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
						max_weight: ::sp_weights::Weight,
					},
					#[codec(index = 2)]
					approve_as_multi {
						threshold: ::core::primitive::u16,
						other_signatories: ::subxt::ext::subxt_core::alloc::vec::Vec<
							::sp_core::crypto::AccountId32,
						>,
						maybe_timepoint: ::core::option::Option<
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						>,
						call_hash: [::core::primitive::u8; 32usize],
						max_weight: ::sp_weights::Weight,
					},
					#[codec(index = 3)]
					cancel_as_multi {
						threshold: ::core::primitive::u16,
						other_signatories: ::subxt::ext::subxt_core::alloc::vec::Vec<
							::sp_core::crypto::AccountId32,
						>,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						call_hash: [::core::primitive::u8; 32usize],
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					MinimumThreshold,
					#[codec(index = 1)]
					AlreadyApproved,
					#[codec(index = 2)]
					NoApprovalsNeeded,
					#[codec(index = 3)]
					TooFewSignatories,
					#[codec(index = 4)]
					TooManySignatories,
					#[codec(index = 5)]
					SignatoriesOutOfOrder,
					#[codec(index = 6)]
					SenderInSignatories,
					#[codec(index = 7)]
					NotFound,
					#[codec(index = 8)]
					NotOwner,
					#[codec(index = 9)]
					NoTimepoint,
					#[codec(index = 10)]
					WrongTimepoint,
					#[codec(index = 11)]
					UnexpectedTimepoint,
					#[codec(index = 12)]
					MaxWeightTooLow,
					#[codec(index = 13)]
					AlreadyStored,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NewMultisig {
						approving: ::sp_core::crypto::AccountId32,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 1)]
					MultisigApproval {
						approving: ::sp_core::crypto::AccountId32,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 2)]
					MultisigExecuted {
						approving: ::sp_core::crypto::AccountId32,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
						result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
					#[codec(index = 3)]
					MultisigCancelled {
						cancelling: ::sp_core::crypto::AccountId32,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
					},
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct Multisig<_0, _1, _2> {
				pub when: runtime_types::pallet_multisig::Timepoint<_0>,
				pub deposit: _1,
				pub depositor: _2,
				pub approvals: runtime_types::bounded_collections::bounded_vec::BoundedVec<_2>,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct Timepoint<_0> {
				pub height: _0,
				pub index: ::core::primitive::u32,
			}
		}
		pub mod pallet_nft_fractionalization {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					fractionalize {
						nft_collection_id: ::core::primitive::u32,
						nft_id: ::core::primitive::u32,
						asset_id: ::core::primitive::u32,
						beneficiary: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						fractions: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					unify {
						nft_collection_id: ::core::primitive::u32,
						nft_id: ::core::primitive::u32,
						asset_id: ::core::primitive::u32,
						beneficiary: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					IncorrectAssetId,
					#[codec(index = 1)]
					NoPermission,
					#[codec(index = 2)]
					NftNotFound,
					#[codec(index = 3)]
					NftNotFractionalized,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NftFractionalized {
						nft_collection: ::core::primitive::u32,
						nft: ::core::primitive::u32,
						fractions: ::core::primitive::u128,
						asset: ::core::primitive::u32,
						beneficiary: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 1)]
					NftUnified {
						nft_collection: ::core::primitive::u32,
						nft: ::core::primitive::u32,
						asset: ::core::primitive::u32,
						beneficiary: ::sp_core::crypto::AccountId32,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum HoldReason {
					#[codec(index = 0)]
					Fractionalized,
				}
			}
			pub mod types {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct Details<_0, _1, _2, _3> {
					pub asset: _0,
					pub fractions: _1,
					pub deposit: _2,
					pub asset_creator: _3,
				}
			}
		}
		pub mod pallet_nfts {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					create {
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						config: runtime_types::pallet_nfts::types::CollectionConfig<
							::core::primitive::u128,
							::core::primitive::u32,
							::core::primitive::u32,
						>,
					},
					#[codec(index = 1)]
					force_create {
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						config: runtime_types::pallet_nfts::types::CollectionConfig<
							::core::primitive::u128,
							::core::primitive::u32,
							::core::primitive::u32,
						>,
					},
					#[codec(index = 2)]
					destroy {
						collection: ::core::primitive::u32,
						witness: runtime_types::pallet_nfts::types::DestroyWitness,
					},
					#[codec(index = 3)]
					mint {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						mint_to: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						witness_data: ::core::option::Option<
							runtime_types::pallet_nfts::types::MintWitness<
								::core::primitive::u32,
								::core::primitive::u128,
							>,
						>,
					},
					#[codec(index = 4)]
					force_mint {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						mint_to: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						item_config: runtime_types::pallet_nfts::types::ItemConfig,
					},
					#[codec(index = 5)]
					burn { collection: ::core::primitive::u32, item: ::core::primitive::u32 },
					#[codec(index = 6)]
					transfer {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 7)]
					redeposit {
						collection: ::core::primitive::u32,
						items: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u32>,
					},
					#[codec(index = 8)]
					lock_item_transfer {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 9)]
					unlock_item_transfer {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 10)]
					lock_collection {
						collection: ::core::primitive::u32,
						lock_settings: runtime_types::pallet_nfts::types::BitFlags1<
							runtime_types::pallet_nfts::types::CollectionSetting,
						>,
					},
					#[codec(index = 11)]
					transfer_ownership {
						collection: ::core::primitive::u32,
						new_owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 12)]
					set_team {
						collection: ::core::primitive::u32,
						issuer: ::core::option::Option<
							::subxt::ext::subxt_core::utils::MultiAddress<
								::sp_core::crypto::AccountId32,
								(),
							>,
						>,
						admin: ::core::option::Option<
							::subxt::ext::subxt_core::utils::MultiAddress<
								::sp_core::crypto::AccountId32,
								(),
							>,
						>,
						freezer: ::core::option::Option<
							::subxt::ext::subxt_core::utils::MultiAddress<
								::sp_core::crypto::AccountId32,
								(),
							>,
						>,
					},
					#[codec(index = 13)]
					force_collection_owner {
						collection: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 14)]
					force_collection_config {
						collection: ::core::primitive::u32,
						config: runtime_types::pallet_nfts::types::CollectionConfig<
							::core::primitive::u128,
							::core::primitive::u32,
							::core::primitive::u32,
						>,
					},
					#[codec(index = 15)]
					approve_transfer {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						maybe_deadline: ::core::option::Option<::core::primitive::u32>,
					},
					#[codec(index = 16)]
					cancel_approval {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 17)]
					clear_all_transfer_approvals {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 18)]
					lock_item_properties {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						lock_metadata: ::core::primitive::bool,
						lock_attributes: ::core::primitive::bool,
					},
					#[codec(index = 19)]
					set_attribute {
						collection: ::core::primitive::u32,
						maybe_item: ::core::option::Option<::core::primitive::u32>,
						namespace: runtime_types::pallet_nfts::types::AttributeNamespace<
							::sp_core::crypto::AccountId32,
						>,
						key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						value: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 20)]
					force_set_attribute {
						set_as: ::core::option::Option<::sp_core::crypto::AccountId32>,
						collection: ::core::primitive::u32,
						maybe_item: ::core::option::Option<::core::primitive::u32>,
						namespace: runtime_types::pallet_nfts::types::AttributeNamespace<
							::sp_core::crypto::AccountId32,
						>,
						key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						value: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 21)]
					clear_attribute {
						collection: ::core::primitive::u32,
						maybe_item: ::core::option::Option<::core::primitive::u32>,
						namespace: runtime_types::pallet_nfts::types::AttributeNamespace<
							::sp_core::crypto::AccountId32,
						>,
						key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 22)]
					approve_item_attributes {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 23)]
					cancel_item_attributes_approval {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						witness: runtime_types::pallet_nfts::types::CancelAttributesApprovalWitness,
					},
					#[codec(index = 24)]
					set_metadata {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 25)]
					clear_metadata {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 26)]
					set_collection_metadata {
						collection: ::core::primitive::u32,
						data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 27)]
					clear_collection_metadata { collection: ::core::primitive::u32 },
					#[codec(index = 28)]
					set_accept_ownership {
						maybe_collection: ::core::option::Option<::core::primitive::u32>,
					},
					#[codec(index = 29)]
					set_collection_max_supply {
						collection: ::core::primitive::u32,
						max_supply: ::core::primitive::u32,
					},
					#[codec(index = 30)]
					update_mint_settings {
						collection: ::core::primitive::u32,
						mint_settings: runtime_types::pallet_nfts::types::MintSettings<
							::core::primitive::u128,
							::core::primitive::u32,
							::core::primitive::u32,
						>,
					},
					#[codec(index = 31)]
					set_price {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						price: ::core::option::Option<::core::primitive::u128>,
						whitelisted_buyer: ::core::option::Option<
							::subxt::ext::subxt_core::utils::MultiAddress<
								::sp_core::crypto::AccountId32,
								(),
							>,
						>,
					},
					#[codec(index = 32)]
					buy_item {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						bid_price: ::core::primitive::u128,
					},
					#[codec(index = 33)]
					pay_tips {
						tips: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							runtime_types::pallet_nfts::types::ItemTip<
								::core::primitive::u32,
								::core::primitive::u32,
								::sp_core::crypto::AccountId32,
								::core::primitive::u128,
							>,
						>,
					},
					#[codec(index = 34)]
					create_swap {
						offered_collection: ::core::primitive::u32,
						offered_item: ::core::primitive::u32,
						desired_collection: ::core::primitive::u32,
						maybe_desired_item: ::core::option::Option<::core::primitive::u32>,
						maybe_price: ::core::option::Option<
							runtime_types::pallet_nfts::types::PriceWithDirection<
								::core::primitive::u128,
							>,
						>,
						duration: ::core::primitive::u32,
					},
					#[codec(index = 35)]
					cancel_swap {
						offered_collection: ::core::primitive::u32,
						offered_item: ::core::primitive::u32,
					},
					#[codec(index = 36)]
					claim_swap {
						send_collection: ::core::primitive::u32,
						send_item: ::core::primitive::u32,
						receive_collection: ::core::primitive::u32,
						receive_item: ::core::primitive::u32,
						witness_price: ::core::option::Option<
							runtime_types::pallet_nfts::types::PriceWithDirection<
								::core::primitive::u128,
							>,
						>,
					},
					#[codec(index = 37)]
					mint_pre_signed {
						mint_data: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::pallet_nfts::types::PreSignedMint<
								::core::primitive::u32,
								::core::primitive::u32,
								::sp_core::crypto::AccountId32,
								::core::primitive::u32,
								::core::primitive::u128,
							>,
						>,
						signature: runtime_types::sp_runtime::MultiSignature,
						signer: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 38)]
					set_attributes_pre_signed {
						data: runtime_types::pallet_nfts::types::PreSignedAttributes<
							::core::primitive::u32,
							::core::primitive::u32,
							::sp_core::crypto::AccountId32,
							::core::primitive::u32,
						>,
						signature: runtime_types::sp_runtime::MultiSignature,
						signer: ::sp_core::crypto::AccountId32,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					NoPermission,
					#[codec(index = 1)]
					UnknownCollection,
					#[codec(index = 2)]
					AlreadyExists,
					#[codec(index = 3)]
					ApprovalExpired,
					#[codec(index = 4)]
					WrongOwner,
					#[codec(index = 5)]
					BadWitness,
					#[codec(index = 6)]
					CollectionIdInUse,
					#[codec(index = 7)]
					ItemsNonTransferable,
					#[codec(index = 8)]
					NotDelegate,
					#[codec(index = 9)]
					WrongDelegate,
					#[codec(index = 10)]
					Unapproved,
					#[codec(index = 11)]
					Unaccepted,
					#[codec(index = 12)]
					ItemLocked,
					#[codec(index = 13)]
					LockedItemAttributes,
					#[codec(index = 14)]
					LockedCollectionAttributes,
					#[codec(index = 15)]
					LockedItemMetadata,
					#[codec(index = 16)]
					LockedCollectionMetadata,
					#[codec(index = 17)]
					MaxSupplyReached,
					#[codec(index = 18)]
					MaxSupplyLocked,
					#[codec(index = 19)]
					MaxSupplyTooSmall,
					#[codec(index = 20)]
					UnknownItem,
					#[codec(index = 21)]
					UnknownSwap,
					#[codec(index = 22)]
					MetadataNotFound,
					#[codec(index = 23)]
					AttributeNotFound,
					#[codec(index = 24)]
					NotForSale,
					#[codec(index = 25)]
					BidTooLow,
					#[codec(index = 26)]
					ReachedApprovalLimit,
					#[codec(index = 27)]
					DeadlineExpired,
					#[codec(index = 28)]
					WrongDuration,
					#[codec(index = 29)]
					MethodDisabled,
					#[codec(index = 30)]
					WrongSetting,
					#[codec(index = 31)]
					InconsistentItemConfig,
					#[codec(index = 32)]
					NoConfig,
					#[codec(index = 33)]
					RolesNotCleared,
					#[codec(index = 34)]
					MintNotStarted,
					#[codec(index = 35)]
					MintEnded,
					#[codec(index = 36)]
					AlreadyClaimed,
					#[codec(index = 37)]
					IncorrectData,
					#[codec(index = 38)]
					WrongOrigin,
					#[codec(index = 39)]
					WrongSignature,
					#[codec(index = 40)]
					IncorrectMetadata,
					#[codec(index = 41)]
					MaxAttributesLimitReached,
					#[codec(index = 42)]
					WrongNamespace,
					#[codec(index = 43)]
					CollectionNotEmpty,
					#[codec(index = 44)]
					WitnessRequired,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Created {
						collection: ::core::primitive::u32,
						creator: ::sp_core::crypto::AccountId32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 1)]
					ForceCreated {
						collection: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 2)]
					Destroyed { collection: ::core::primitive::u32 },
					#[codec(index = 3)]
					Issued {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 4)]
					Transferred {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						from: ::sp_core::crypto::AccountId32,
						to: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 5)]
					Burned {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 6)]
					ItemTransferLocked {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 7)]
					ItemTransferUnlocked {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					ItemPropertiesLocked {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						lock_metadata: ::core::primitive::bool,
						lock_attributes: ::core::primitive::bool,
					},
					#[codec(index = 9)]
					CollectionLocked { collection: ::core::primitive::u32 },
					#[codec(index = 10)]
					OwnerChanged {
						collection: ::core::primitive::u32,
						new_owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 11)]
					TeamChanged {
						collection: ::core::primitive::u32,
						issuer: ::core::option::Option<::sp_core::crypto::AccountId32>,
						admin: ::core::option::Option<::sp_core::crypto::AccountId32>,
						freezer: ::core::option::Option<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 12)]
					TransferApproved {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
						delegate: ::sp_core::crypto::AccountId32,
						deadline: ::core::option::Option<::core::primitive::u32>,
					},
					#[codec(index = 13)]
					ApprovalCancelled {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
						delegate: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 14)]
					AllApprovalsCancelled {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 15)]
					CollectionConfigChanged { collection: ::core::primitive::u32 },
					#[codec(index = 16)]
					CollectionMetadataSet {
						collection: ::core::primitive::u32,
						data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 17)]
					CollectionMetadataCleared { collection: ::core::primitive::u32 },
					#[codec(index = 18)]
					ItemMetadataSet {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 19)]
					ItemMetadataCleared {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 20)]
					Redeposited {
						collection: ::core::primitive::u32,
						successful_items:
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u32>,
					},
					#[codec(index = 21)]
					AttributeSet {
						collection: ::core::primitive::u32,
						maybe_item: ::core::option::Option<::core::primitive::u32>,
						key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						value: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						namespace: runtime_types::pallet_nfts::types::AttributeNamespace<
							::sp_core::crypto::AccountId32,
						>,
					},
					#[codec(index = 22)]
					AttributeCleared {
						collection: ::core::primitive::u32,
						maybe_item: ::core::option::Option<::core::primitive::u32>,
						key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						namespace: runtime_types::pallet_nfts::types::AttributeNamespace<
							::sp_core::crypto::AccountId32,
						>,
					},
					#[codec(index = 23)]
					ItemAttributesApprovalAdded {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						delegate: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 24)]
					ItemAttributesApprovalRemoved {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						delegate: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 25)]
					OwnershipAcceptanceChanged {
						who: ::sp_core::crypto::AccountId32,
						maybe_collection: ::core::option::Option<::core::primitive::u32>,
					},
					#[codec(index = 26)]
					CollectionMaxSupplySet {
						collection: ::core::primitive::u32,
						max_supply: ::core::primitive::u32,
					},
					#[codec(index = 27)]
					CollectionMintSettingsUpdated { collection: ::core::primitive::u32 },
					#[codec(index = 28)]
					NextCollectionIdIncremented {
						next_id: ::core::option::Option<::core::primitive::u32>,
					},
					#[codec(index = 29)]
					ItemPriceSet {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						price: ::core::primitive::u128,
						whitelisted_buyer: ::core::option::Option<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 30)]
					ItemPriceRemoved {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 31)]
					ItemBought {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						price: ::core::primitive::u128,
						seller: ::sp_core::crypto::AccountId32,
						buyer: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 32)]
					TipSent {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						sender: ::sp_core::crypto::AccountId32,
						receiver: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 33)]
					SwapCreated {
						offered_collection: ::core::primitive::u32,
						offered_item: ::core::primitive::u32,
						desired_collection: ::core::primitive::u32,
						desired_item: ::core::option::Option<::core::primitive::u32>,
						price: ::core::option::Option<
							runtime_types::pallet_nfts::types::PriceWithDirection<
								::core::primitive::u128,
							>,
						>,
						deadline: ::core::primitive::u32,
					},
					#[codec(index = 34)]
					SwapCancelled {
						offered_collection: ::core::primitive::u32,
						offered_item: ::core::primitive::u32,
						desired_collection: ::core::primitive::u32,
						desired_item: ::core::option::Option<::core::primitive::u32>,
						price: ::core::option::Option<
							runtime_types::pallet_nfts::types::PriceWithDirection<
								::core::primitive::u128,
							>,
						>,
						deadline: ::core::primitive::u32,
					},
					#[codec(index = 35)]
					SwapClaimed {
						sent_collection: ::core::primitive::u32,
						sent_item: ::core::primitive::u32,
						sent_item_owner: ::sp_core::crypto::AccountId32,
						received_collection: ::core::primitive::u32,
						received_item: ::core::primitive::u32,
						received_item_owner: ::sp_core::crypto::AccountId32,
						price: ::core::option::Option<
							runtime_types::pallet_nfts::types::PriceWithDirection<
								::core::primitive::u128,
							>,
						>,
						deadline: ::core::primitive::u32,
					},
					#[codec(index = 36)]
					PreSignedAttributesSet {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						namespace: runtime_types::pallet_nfts::types::AttributeNamespace<
							::sp_core::crypto::AccountId32,
						>,
					},
					#[codec(index = 37)]
					PalletAttributeSet {
						collection: ::core::primitive::u32,
						item: ::core::option::Option<::core::primitive::u32>,
						attribute: runtime_types::pallet_nfts::types::PalletAttributes<
							::core::primitive::u32,
						>,
						value: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
				}
			}
			pub mod types {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct AttributeDeposit<_0, _1> {
					pub account: ::core::option::Option<_1>,
					pub amount: _0,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum AttributeNamespace<_0> {
					#[codec(index = 0)]
					Pallet,
					#[codec(index = 1)]
					CollectionOwner,
					#[codec(index = 2)]
					ItemOwner,
					#[codec(index = 3)]
					Account(_0),
				}
				#[derive(
					::codec::Decode,
					::codec::Encode,
					::subxt::ext::subxt_core::ext::codec::CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct BitFlags1<_0>(
					pub ::core::primitive::u64,
					#[codec(skip)] pub ::core::marker::PhantomData<_0>,
				);
				#[derive(
					::codec::Decode,
					::codec::Encode,
					::subxt::ext::subxt_core::ext::codec::CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct BitFlags2<_0>(
					pub ::core::primitive::u8,
					#[codec(skip)] pub ::core::marker::PhantomData<_0>,
				);
				#[derive(
					::codec::Decode,
					::codec::Encode,
					::subxt::ext::subxt_core::ext::codec::CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct CancelAttributesApprovalWitness {
					pub account_attributes: ::core::primitive::u32,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct CollectionConfig<_0, _1, _2> {
					pub settings: runtime_types::pallet_nfts::types::BitFlags1<
						runtime_types::pallet_nfts::types::CollectionSetting,
					>,
					pub max_supply: ::core::option::Option<_1>,
					pub mint_settings: runtime_types::pallet_nfts::types::MintSettings<_0, _1, _1>,
					#[codec(skip)]
					pub __ignore: ::core::marker::PhantomData<_2>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct CollectionDetails<_0, _1> {
					pub owner: _0,
					pub owner_deposit: _1,
					pub items: ::core::primitive::u32,
					pub item_metadatas: ::core::primitive::u32,
					pub item_configs: ::core::primitive::u32,
					pub attributes: ::core::primitive::u32,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct CollectionMetadata<_0> {
					pub deposit: _0,
					pub data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum CollectionRole {
					#[codec(index = 1)]
					Issuer,
					#[codec(index = 2)]
					Freezer,
					#[codec(index = 4)]
					Admin,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum CollectionSetting {
					#[codec(index = 1)]
					TransferableItems,
					#[codec(index = 2)]
					UnlockedMetadata,
					#[codec(index = 4)]
					UnlockedAttributes,
					#[codec(index = 8)]
					UnlockedMaxSupply,
					#[codec(index = 16)]
					DepositRequired,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct DestroyWitness {
					#[codec(compact)]
					pub item_metadatas: ::core::primitive::u32,
					#[codec(compact)]
					pub item_configs: ::core::primitive::u32,
					#[codec(compact)]
					pub attributes: ::core::primitive::u32,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct ItemConfig {
					pub settings: runtime_types::pallet_nfts::types::BitFlags1<
						runtime_types::pallet_nfts::types::ItemSetting,
					>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct ItemDeposit<_0, _1> {
					pub account: _1,
					pub amount: _0,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct ItemDetails<_0, _1, _2> {
					pub owner: _0,
					pub approvals: _2,
					pub deposit: _1,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct ItemMetadata<_0> {
					pub deposit: _0,
					pub data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct ItemMetadataDeposit<_0, _1> {
					pub account: ::core::option::Option<_1>,
					pub amount: _0,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum ItemSetting {
					#[codec(index = 1)]
					Transferable,
					#[codec(index = 2)]
					UnlockedMetadata,
					#[codec(index = 4)]
					UnlockedAttributes,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct ItemTip<_0, _1, _2, _3> {
					pub collection: _0,
					pub item: _1,
					pub receiver: _2,
					pub amount: _3,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct MintSettings<_0, _1, _2> {
					pub mint_type: runtime_types::pallet_nfts::types::MintType<_1>,
					pub price: ::core::option::Option<_0>,
					pub start_block: ::core::option::Option<_1>,
					pub end_block: ::core::option::Option<_1>,
					pub default_item_settings: runtime_types::pallet_nfts::types::BitFlags1<
						runtime_types::pallet_nfts::types::ItemSetting,
					>,
					#[codec(skip)]
					pub __ignore: ::core::marker::PhantomData<_2>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum MintType<_0> {
					#[codec(index = 0)]
					Issuer,
					#[codec(index = 1)]
					Public,
					#[codec(index = 2)]
					HolderOf(_0),
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct MintWitness<_0, _1> {
					pub owned_item: ::core::option::Option<_0>,
					pub mint_price: ::core::option::Option<_1>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum PalletAttributes<_0> {
					#[codec(index = 0)]
					UsedToClaim(_0),
					#[codec(index = 1)]
					TransferDisabled,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum PalletFeature {
					#[codec(index = 1)]
					Trading,
					#[codec(index = 2)]
					Attributes,
					#[codec(index = 4)]
					Approvals,
					#[codec(index = 8)]
					Swaps,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct PendingSwap<_0, _1, _2, _3> {
					pub desired_collection: _0,
					pub desired_item: ::core::option::Option<_0>,
					pub price: ::core::option::Option<_2>,
					pub deadline: _3,
					#[codec(skip)]
					pub __ignore: ::core::marker::PhantomData<_1>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct PreSignedAttributes<_0, _1, _2, _3> {
					pub collection: _0,
					pub item: _1,
					pub attributes: ::subxt::ext::subxt_core::alloc::vec::Vec<(
						::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
					)>,
					pub namespace: runtime_types::pallet_nfts::types::AttributeNamespace<_2>,
					pub deadline: _3,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct PreSignedMint<_0, _1, _2, _3, _4> {
					pub collection: _0,
					pub item: _1,
					pub attributes: ::subxt::ext::subxt_core::alloc::vec::Vec<(
						::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
					)>,
					pub metadata: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
					pub only_account: ::core::option::Option<_2>,
					pub deadline: _3,
					pub mint_price: ::core::option::Option<_4>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum PriceDirection {
					#[codec(index = 0)]
					Send,
					#[codec(index = 1)]
					Receive,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct PriceWithDirection<_0> {
					pub amount: _0,
					pub direction: runtime_types::pallet_nfts::types::PriceDirection,
				}
			}
		}
		pub mod pallet_proxy {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					proxy {
						real: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						force_proxy_type: ::core::option::Option<
							runtime_types::asset_hub_rococo_runtime::ProxyType,
						>,
						call: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 1)]
					add_proxy {
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						proxy_type: runtime_types::asset_hub_rococo_runtime::ProxyType,
						delay: ::core::primitive::u32,
					},
					#[codec(index = 2)]
					remove_proxy {
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						proxy_type: runtime_types::asset_hub_rococo_runtime::ProxyType,
						delay: ::core::primitive::u32,
					},
					#[codec(index = 3)]
					remove_proxies,
					#[codec(index = 4)]
					create_pure {
						proxy_type: runtime_types::asset_hub_rococo_runtime::ProxyType,
						delay: ::core::primitive::u32,
						index: ::core::primitive::u16,
					},
					#[codec(index = 5)]
					kill_pure {
						spawner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						proxy_type: runtime_types::asset_hub_rococo_runtime::ProxyType,
						index: ::core::primitive::u16,
						#[codec(compact)]
						height: ::core::primitive::u32,
						#[codec(compact)]
						ext_index: ::core::primitive::u32,
					},
					#[codec(index = 6)]
					announce {
						real: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						call_hash: ::subxt::ext::subxt_core::utils::H256,
					},
					#[codec(index = 7)]
					remove_announcement {
						real: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						call_hash: ::subxt::ext::subxt_core::utils::H256,
					},
					#[codec(index = 8)]
					reject_announcement {
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						call_hash: ::subxt::ext::subxt_core::utils::H256,
					},
					#[codec(index = 9)]
					proxy_announced {
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						real: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						force_proxy_type: ::core::option::Option<
							runtime_types::asset_hub_rococo_runtime::ProxyType,
						>,
						call: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					TooMany,
					#[codec(index = 1)]
					NotFound,
					#[codec(index = 2)]
					NotProxy,
					#[codec(index = 3)]
					Unproxyable,
					#[codec(index = 4)]
					Duplicate,
					#[codec(index = 5)]
					NoPermission,
					#[codec(index = 6)]
					Unannounced,
					#[codec(index = 7)]
					NoSelfProxy,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ProxyExecuted {
						result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
					#[codec(index = 1)]
					PureCreated {
						pure: ::sp_core::crypto::AccountId32,
						who: ::sp_core::crypto::AccountId32,
						proxy_type: runtime_types::asset_hub_rococo_runtime::ProxyType,
						disambiguation_index: ::core::primitive::u16,
					},
					#[codec(index = 2)]
					Announced {
						real: ::sp_core::crypto::AccountId32,
						proxy: ::sp_core::crypto::AccountId32,
						call_hash: ::subxt::ext::subxt_core::utils::H256,
					},
					#[codec(index = 3)]
					ProxyAdded {
						delegator: ::sp_core::crypto::AccountId32,
						delegatee: ::sp_core::crypto::AccountId32,
						proxy_type: runtime_types::asset_hub_rococo_runtime::ProxyType,
						delay: ::core::primitive::u32,
					},
					#[codec(index = 4)]
					ProxyRemoved {
						delegator: ::sp_core::crypto::AccountId32,
						delegatee: ::sp_core::crypto::AccountId32,
						proxy_type: runtime_types::asset_hub_rococo_runtime::ProxyType,
						delay: ::core::primitive::u32,
					},
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct Announcement<_0, _1, _2> {
				pub real: _0,
				pub call_hash: _1,
				pub height: _2,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct ProxyDefinition<_0, _1, _2> {
				pub delegate: _0,
				pub proxy_type: _1,
				pub delay: _2,
			}
		}
		pub mod pallet_session {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set_keys {
						keys: runtime_types::asset_hub_rococo_runtime::SessionKeys,
						proof: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 1)]
					purge_keys,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidProof,
					#[codec(index = 1)]
					NoAssociatedValidatorId,
					#[codec(index = 2)]
					DuplicatedKey,
					#[codec(index = 3)]
					NoKeys,
					#[codec(index = 4)]
					NoAccount,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NewSession { session_index: ::core::primitive::u32 },
				}
			}
		}
		pub mod pallet_timestamp {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set {
						#[codec(compact)]
						now: ::core::primitive::u64,
					},
				}
			}
		}
		pub mod pallet_transaction_payment {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					TransactionFeePaid {
						who: ::sp_core::crypto::AccountId32,
						actual_fee: ::core::primitive::u128,
						tip: ::core::primitive::u128,
					},
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum Releases {
				#[codec(index = 0)]
				V1Ancient,
				#[codec(index = 1)]
				V2,
			}
		}
		pub mod pallet_uniques {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					create {
						collection: ::core::primitive::u32,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 1)]
					force_create {
						collection: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						free_holding: ::core::primitive::bool,
					},
					#[codec(index = 2)]
					destroy {
						collection: ::core::primitive::u32,
						witness: runtime_types::pallet_uniques::types::DestroyWitness,
					},
					#[codec(index = 3)]
					mint {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 4)]
					burn {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						check_owner: ::core::option::Option<
							::subxt::ext::subxt_core::utils::MultiAddress<
								::sp_core::crypto::AccountId32,
								(),
							>,
						>,
					},
					#[codec(index = 5)]
					transfer {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						dest: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 6)]
					redeposit {
						collection: ::core::primitive::u32,
						items: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u32>,
					},
					#[codec(index = 7)]
					freeze { collection: ::core::primitive::u32, item: ::core::primitive::u32 },
					#[codec(index = 8)]
					thaw { collection: ::core::primitive::u32, item: ::core::primitive::u32 },
					#[codec(index = 9)]
					freeze_collection { collection: ::core::primitive::u32 },
					#[codec(index = 10)]
					thaw_collection { collection: ::core::primitive::u32 },
					#[codec(index = 11)]
					transfer_ownership {
						collection: ::core::primitive::u32,
						new_owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 12)]
					set_team {
						collection: ::core::primitive::u32,
						issuer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						freezer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 13)]
					approve_transfer {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						delegate: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
					},
					#[codec(index = 14)]
					cancel_approval {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						maybe_check_delegate: ::core::option::Option<
							::subxt::ext::subxt_core::utils::MultiAddress<
								::sp_core::crypto::AccountId32,
								(),
							>,
						>,
					},
					#[codec(index = 15)]
					force_item_status {
						collection: ::core::primitive::u32,
						owner: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						issuer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						admin: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						freezer: ::subxt::ext::subxt_core::utils::MultiAddress<
							::sp_core::crypto::AccountId32,
							(),
						>,
						free_holding: ::core::primitive::bool,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					set_attribute {
						collection: ::core::primitive::u32,
						maybe_item: ::core::option::Option<::core::primitive::u32>,
						key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						value: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 17)]
					clear_attribute {
						collection: ::core::primitive::u32,
						maybe_item: ::core::option::Option<::core::primitive::u32>,
						key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 18)]
					set_metadata {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 19)]
					clear_metadata {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 20)]
					set_collection_metadata {
						collection: ::core::primitive::u32,
						data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 21)]
					clear_collection_metadata { collection: ::core::primitive::u32 },
					#[codec(index = 22)]
					set_accept_ownership {
						maybe_collection: ::core::option::Option<::core::primitive::u32>,
					},
					#[codec(index = 23)]
					set_collection_max_supply {
						collection: ::core::primitive::u32,
						max_supply: ::core::primitive::u32,
					},
					#[codec(index = 24)]
					set_price {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						price: ::core::option::Option<::core::primitive::u128>,
						whitelisted_buyer: ::core::option::Option<
							::subxt::ext::subxt_core::utils::MultiAddress<
								::sp_core::crypto::AccountId32,
								(),
							>,
						>,
					},
					#[codec(index = 25)]
					buy_item {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						bid_price: ::core::primitive::u128,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					NoPermission,
					#[codec(index = 1)]
					UnknownCollection,
					#[codec(index = 2)]
					AlreadyExists,
					#[codec(index = 3)]
					WrongOwner,
					#[codec(index = 4)]
					BadWitness,
					#[codec(index = 5)]
					InUse,
					#[codec(index = 6)]
					Frozen,
					#[codec(index = 7)]
					WrongDelegate,
					#[codec(index = 8)]
					NoDelegate,
					#[codec(index = 9)]
					Unapproved,
					#[codec(index = 10)]
					Unaccepted,
					#[codec(index = 11)]
					Locked,
					#[codec(index = 12)]
					MaxSupplyReached,
					#[codec(index = 13)]
					MaxSupplyAlreadySet,
					#[codec(index = 14)]
					MaxSupplyTooSmall,
					#[codec(index = 15)]
					UnknownItem,
					#[codec(index = 16)]
					NotForSale,
					#[codec(index = 17)]
					BidTooLow,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Created {
						collection: ::core::primitive::u32,
						creator: ::sp_core::crypto::AccountId32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 1)]
					ForceCreated {
						collection: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 2)]
					Destroyed { collection: ::core::primitive::u32 },
					#[codec(index = 3)]
					Issued {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 4)]
					Transferred {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						from: ::sp_core::crypto::AccountId32,
						to: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 5)]
					Burned {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 6)]
					Frozen { collection: ::core::primitive::u32, item: ::core::primitive::u32 },
					#[codec(index = 7)]
					Thawed { collection: ::core::primitive::u32, item: ::core::primitive::u32 },
					#[codec(index = 8)]
					CollectionFrozen { collection: ::core::primitive::u32 },
					#[codec(index = 9)]
					CollectionThawed { collection: ::core::primitive::u32 },
					#[codec(index = 10)]
					OwnerChanged {
						collection: ::core::primitive::u32,
						new_owner: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 11)]
					TeamChanged {
						collection: ::core::primitive::u32,
						issuer: ::sp_core::crypto::AccountId32,
						admin: ::sp_core::crypto::AccountId32,
						freezer: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 12)]
					ApprovedTransfer {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
						delegate: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 13)]
					ApprovalCancelled {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						owner: ::sp_core::crypto::AccountId32,
						delegate: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 14)]
					ItemStatusChanged { collection: ::core::primitive::u32 },
					#[codec(index = 15)]
					CollectionMetadataSet {
						collection: ::core::primitive::u32,
						data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					CollectionMetadataCleared { collection: ::core::primitive::u32 },
					#[codec(index = 17)]
					MetadataSet {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						is_frozen: ::core::primitive::bool,
					},
					#[codec(index = 18)]
					MetadataCleared {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 19)]
					Redeposited {
						collection: ::core::primitive::u32,
						successful_items:
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u32>,
					},
					#[codec(index = 20)]
					AttributeSet {
						collection: ::core::primitive::u32,
						maybe_item: ::core::option::Option<::core::primitive::u32>,
						key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
						value: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 21)]
					AttributeCleared {
						collection: ::core::primitive::u32,
						maybe_item: ::core::option::Option<::core::primitive::u32>,
						key: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					},
					#[codec(index = 22)]
					OwnershipAcceptanceChanged {
						who: ::sp_core::crypto::AccountId32,
						maybe_collection: ::core::option::Option<::core::primitive::u32>,
					},
					#[codec(index = 23)]
					CollectionMaxSupplySet {
						collection: ::core::primitive::u32,
						max_supply: ::core::primitive::u32,
					},
					#[codec(index = 24)]
					ItemPriceSet {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						price: ::core::primitive::u128,
						whitelisted_buyer: ::core::option::Option<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 25)]
					ItemPriceRemoved {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
					},
					#[codec(index = 26)]
					ItemBought {
						collection: ::core::primitive::u32,
						item: ::core::primitive::u32,
						price: ::core::primitive::u128,
						seller: ::sp_core::crypto::AccountId32,
						buyer: ::sp_core::crypto::AccountId32,
					},
				}
			}
			pub mod types {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct CollectionDetails<_0, _1> {
					pub owner: _0,
					pub issuer: _0,
					pub admin: _0,
					pub freezer: _0,
					pub total_deposit: _1,
					pub free_holding: ::core::primitive::bool,
					pub items: ::core::primitive::u32,
					pub item_metadatas: ::core::primitive::u32,
					pub attributes: ::core::primitive::u32,
					pub is_frozen: ::core::primitive::bool,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct CollectionMetadata<_0> {
					pub deposit: _0,
					pub data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					pub is_frozen: ::core::primitive::bool,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct DestroyWitness {
					#[codec(compact)]
					pub items: ::core::primitive::u32,
					#[codec(compact)]
					pub item_metadatas: ::core::primitive::u32,
					#[codec(compact)]
					pub attributes: ::core::primitive::u32,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct ItemDetails<_0, _1> {
					pub owner: _0,
					pub approved: ::core::option::Option<_0>,
					pub is_frozen: ::core::primitive::bool,
					pub deposit: _1,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct ItemMetadata<_0> {
					pub deposit: _0,
					pub data: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					pub is_frozen: ::core::primitive::bool,
				}
			}
		}
		pub mod pallet_utility {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					batch {
						calls: ::subxt::ext::subxt_core::alloc::vec::Vec<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 1)]
					as_derivative {
						index: ::core::primitive::u16,
						call: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 2)]
					batch_all {
						calls: ::subxt::ext::subxt_core::alloc::vec::Vec<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 3)]
					dispatch_as {
						as_origin: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::asset_hub_rococo_runtime::OriginCaller,
						>,
						call: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 4)]
					force_batch {
						calls: ::subxt::ext::subxt_core::alloc::vec::Vec<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 5)]
					with_weight {
						call: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
						weight: ::sp_weights::Weight,
					},
					#[codec(index = 6)]
					if_else {
						main: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
						fallback: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::asset_hub_rococo_runtime::RuntimeCall,
						>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					TooManyCalls,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					BatchInterrupted {
						index: ::core::primitive::u32,
						error: runtime_types::sp_runtime::DispatchError,
					},
					#[codec(index = 1)]
					BatchCompleted,
					#[codec(index = 2)]
					BatchCompletedWithErrors,
					#[codec(index = 3)]
					ItemCompleted,
					#[codec(index = 4)]
					ItemFailed { error: runtime_types::sp_runtime::DispatchError },
					#[codec(index = 5)]
					DispatchedAs {
						result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
					#[codec(index = 6)]
					IfElseMainSuccess,
					#[codec(index = 7)]
					IfElseFallbackCalled { main_error: runtime_types::sp_runtime::DispatchError },
				}
			}
		}
		pub mod pallet_xcm {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
                    send {
                        dest: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        message: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedXcm,
                        >,
                    },
                    #[codec(index = 1)]
                    teleport_assets {
                        dest: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        beneficiary: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        assets: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedAssets,
                        >,
                        fee_asset_item: ::core::primitive::u32,
                    },
                    #[codec(index = 2)]
                    reserve_transfer_assets {
                        dest: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        beneficiary: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        assets: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedAssets,
                        >,
                        fee_asset_item: ::core::primitive::u32,
                    },
                    #[codec(index = 3)]
                    execute {
                        message: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedXcm,
                        >,
                        max_weight: ::sp_weights::Weight,
                    },
                    #[codec(index = 4)]
                    force_xcm_version {
                        location: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::staging_xcm::v5::location::Location,
                        >,
                        version: ::core::primitive::u32,
                    },
                    #[codec(index = 5)]
                    force_default_xcm_version {
                        maybe_xcm_version: ::core::option::Option<::core::primitive::u32>,
                    },
                    #[codec(index = 6)]
                    force_subscribe_version_notify {
                        location: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                    },
                    #[codec(index = 7)]
                    force_unsubscribe_version_notify {
                        location: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                    },
                    #[codec(index = 8)]
                    limited_reserve_transfer_assets {
                        dest: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        beneficiary: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        assets: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedAssets,
                        >,
                        fee_asset_item: ::core::primitive::u32,
                        weight_limit: runtime_types::xcm::v3::WeightLimit,
                    },
                    #[codec(index = 9)]
                    limited_teleport_assets {
                        dest: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        beneficiary: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        assets: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedAssets,
                        >,
                        fee_asset_item: ::core::primitive::u32,
                        weight_limit: runtime_types::xcm::v3::WeightLimit,
                    },
                    #[codec(index = 10)]
                    force_suspension { suspended: ::core::primitive::bool },
                    #[codec(index = 11)]
                    transfer_assets {
                        dest: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        beneficiary: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        assets: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedAssets,
                        >,
                        fee_asset_item: ::core::primitive::u32,
                        weight_limit: runtime_types::xcm::v3::WeightLimit,
                    },
                    #[codec(index = 12)]
                    claim_assets {
                        assets: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedAssets,
                        >,
                        beneficiary: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                    },
                    #[codec(index = 13)]
                    transfer_assets_using_type_and_then {
                        dest: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedLocation,
                        >,
                        assets: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedAssets,
                        >,
                        assets_transfer_type: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::staging_xcm_executor::traits::asset_transfer::TransferType,
                        >,
                        remote_fees_id: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedAssetId,
                        >,
                        fees_transfer_type: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::staging_xcm_executor::traits::asset_transfer::TransferType,
                        >,
                        custom_xcm_on_dest: ::subxt::ext::subxt_core::alloc::boxed::Box<
                            runtime_types::xcm::VersionedXcm,
                        >,
                        weight_limit: runtime_types::xcm::v3::WeightLimit,
                    },
                }
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					Unreachable,
					#[codec(index = 1)]
					SendFailure,
					#[codec(index = 2)]
					Filtered,
					#[codec(index = 3)]
					UnweighableMessage,
					#[codec(index = 4)]
					DestinationNotInvertible,
					#[codec(index = 5)]
					Empty,
					#[codec(index = 6)]
					CannotReanchor,
					#[codec(index = 7)]
					TooManyAssets,
					#[codec(index = 8)]
					InvalidOrigin,
					#[codec(index = 9)]
					BadVersion,
					#[codec(index = 10)]
					BadLocation,
					#[codec(index = 11)]
					NoSubscription,
					#[codec(index = 12)]
					AlreadySubscribed,
					#[codec(index = 13)]
					CannotCheckOutTeleport,
					#[codec(index = 14)]
					LowBalance,
					#[codec(index = 15)]
					TooManyLocks,
					#[codec(index = 16)]
					AccountNotSovereign,
					#[codec(index = 17)]
					FeesNotMet,
					#[codec(index = 18)]
					LockNotFound,
					#[codec(index = 19)]
					InUse,
					#[codec(index = 21)]
					InvalidAssetUnknownReserve,
					#[codec(index = 22)]
					InvalidAssetUnsupportedReserve,
					#[codec(index = 23)]
					TooManyReserves,
					#[codec(index = 24)]
					LocalExecutionIncomplete,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Attempted { outcome: runtime_types::staging_xcm::v5::traits::Outcome },
					#[codec(index = 1)]
					Sent {
						origin: runtime_types::staging_xcm::v5::location::Location,
						destination: runtime_types::staging_xcm::v5::location::Location,
						message: runtime_types::staging_xcm::v5::Xcm,
						message_id: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 2)]
					UnexpectedResponse {
						origin: runtime_types::staging_xcm::v5::location::Location,
						query_id: ::core::primitive::u64,
					},
					#[codec(index = 3)]
					ResponseReady {
						query_id: ::core::primitive::u64,
						response: runtime_types::staging_xcm::v5::Response,
					},
					#[codec(index = 4)]
					Notified {
						query_id: ::core::primitive::u64,
						pallet_index: ::core::primitive::u8,
						call_index: ::core::primitive::u8,
					},
					#[codec(index = 5)]
					NotifyOverweight {
						query_id: ::core::primitive::u64,
						pallet_index: ::core::primitive::u8,
						call_index: ::core::primitive::u8,
						actual_weight: ::sp_weights::Weight,
						max_budgeted_weight: ::sp_weights::Weight,
					},
					#[codec(index = 6)]
					NotifyDispatchError {
						query_id: ::core::primitive::u64,
						pallet_index: ::core::primitive::u8,
						call_index: ::core::primitive::u8,
					},
					#[codec(index = 7)]
					NotifyDecodeFailed {
						query_id: ::core::primitive::u64,
						pallet_index: ::core::primitive::u8,
						call_index: ::core::primitive::u8,
					},
					#[codec(index = 8)]
					InvalidResponder {
						origin: runtime_types::staging_xcm::v5::location::Location,
						query_id: ::core::primitive::u64,
						expected_location: ::core::option::Option<
							runtime_types::staging_xcm::v5::location::Location,
						>,
					},
					#[codec(index = 9)]
					InvalidResponderVersion {
						origin: runtime_types::staging_xcm::v5::location::Location,
						query_id: ::core::primitive::u64,
					},
					#[codec(index = 10)]
					ResponseTaken { query_id: ::core::primitive::u64 },
					#[codec(index = 11)]
					AssetsTrapped {
						hash: ::subxt::ext::subxt_core::utils::H256,
						origin: runtime_types::staging_xcm::v5::location::Location,
						assets: runtime_types::xcm::VersionedAssets,
					},
					#[codec(index = 12)]
					VersionChangeNotified {
						destination: runtime_types::staging_xcm::v5::location::Location,
						result: ::core::primitive::u32,
						cost: runtime_types::staging_xcm::v5::asset::Assets,
						message_id: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 13)]
					SupportedVersionChanged {
						location: runtime_types::staging_xcm::v5::location::Location,
						version: ::core::primitive::u32,
					},
					#[codec(index = 14)]
					NotifyTargetSendFail {
						location: runtime_types::staging_xcm::v5::location::Location,
						query_id: ::core::primitive::u64,
						error: runtime_types::xcm::v5::traits::Error,
					},
					#[codec(index = 15)]
					NotifyTargetMigrationFail {
						location: runtime_types::xcm::VersionedLocation,
						query_id: ::core::primitive::u64,
					},
					#[codec(index = 16)]
					InvalidQuerierVersion {
						origin: runtime_types::staging_xcm::v5::location::Location,
						query_id: ::core::primitive::u64,
					},
					#[codec(index = 17)]
					InvalidQuerier {
						origin: runtime_types::staging_xcm::v5::location::Location,
						query_id: ::core::primitive::u64,
						expected_querier: runtime_types::staging_xcm::v5::location::Location,
						maybe_actual_querier: ::core::option::Option<
							runtime_types::staging_xcm::v5::location::Location,
						>,
					},
					#[codec(index = 18)]
					VersionNotifyStarted {
						destination: runtime_types::staging_xcm::v5::location::Location,
						cost: runtime_types::staging_xcm::v5::asset::Assets,
						message_id: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 19)]
					VersionNotifyRequested {
						destination: runtime_types::staging_xcm::v5::location::Location,
						cost: runtime_types::staging_xcm::v5::asset::Assets,
						message_id: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 20)]
					VersionNotifyUnrequested {
						destination: runtime_types::staging_xcm::v5::location::Location,
						cost: runtime_types::staging_xcm::v5::asset::Assets,
						message_id: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 21)]
					FeesPaid {
						paying: runtime_types::staging_xcm::v5::location::Location,
						fees: runtime_types::staging_xcm::v5::asset::Assets,
					},
					#[codec(index = 22)]
					AssetsClaimed {
						hash: ::subxt::ext::subxt_core::utils::H256,
						origin: runtime_types::staging_xcm::v5::location::Location,
						assets: runtime_types::xcm::VersionedAssets,
					},
					#[codec(index = 23)]
					VersionMigrationFinished { version: ::core::primitive::u32 },
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Origin {
					#[codec(index = 0)]
					Xcm(runtime_types::staging_xcm::v5::location::Location),
					#[codec(index = 1)]
					Response(runtime_types::staging_xcm::v5::location::Location),
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum QueryStatus<_0> {
					#[codec(index = 0)]
					Pending {
						responder: runtime_types::xcm::VersionedLocation,
						maybe_match_querier:
							::core::option::Option<runtime_types::xcm::VersionedLocation>,
						maybe_notify:
							::core::option::Option<(::core::primitive::u8, ::core::primitive::u8)>,
						timeout: _0,
					},
					#[codec(index = 1)]
					VersionNotifier {
						origin: runtime_types::xcm::VersionedLocation,
						is_active: ::core::primitive::bool,
					},
					#[codec(index = 2)]
					Ready { response: runtime_types::xcm::VersionedResponse, at: _0 },
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct RemoteLockedFungibleRecord<_0> {
					pub amount: ::core::primitive::u128,
					pub owner: runtime_types::xcm::VersionedLocation,
					pub locker: runtime_types::xcm::VersionedLocation,
					pub consumers: runtime_types::bounded_collections::bounded_vec::BoundedVec<(
						_0,
						::core::primitive::u128,
					)>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum VersionMigrationStage {
					#[codec(index = 0)]
					MigrateSupportedVersion,
					#[codec(index = 1)]
					MigrateVersionNotifiers,
					#[codec(index = 2)]
					NotifyCurrentTargets(
						::core::option::Option<
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						>,
					),
					#[codec(index = 3)]
					MigrateAndNotifyOldTargets,
				}
			}
		}
		pub mod pallet_xcm_bridge {
			use super::runtime_types;
			pub mod dispatcher {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum XcmBlobMessageDispatchResult {
					#[codec(index = 0)]
					InvalidPayload,
					#[codec(index = 1)]
					Dispatched,
					#[codec(index = 2)]
					NotDispatched,
				}
			}
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					open_bridge {
						bridge_destination_universal_location:
							::subxt::ext::subxt_core::alloc::boxed::Box<
								runtime_types::xcm::VersionedInteriorLocation,
							>,
						maybe_notify:
							::core::option::Option<runtime_types::bp_xcm_bridge::Receiver>,
					},
					#[codec(index = 1)]
					close_bridge {
						bridge_destination_universal_location:
							::subxt::ext::subxt_core::alloc::boxed::Box<
								runtime_types::xcm::VersionedInteriorLocation,
							>,
						may_prune_messages: ::core::primitive::u64,
					},
					#[codec(index = 2)]
					update_notification_receiver {
						bridge_destination_universal_location:
							::subxt::ext::subxt_core::alloc::boxed::Box<
								runtime_types::xcm::VersionedInteriorLocation,
							>,
						maybe_notify:
							::core::option::Option<runtime_types::bp_xcm_bridge::Receiver>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					BridgeLocations(runtime_types::bp_xcm_bridge::BridgeLocationsError),
					#[codec(index = 1)]
					InvalidBridgeOriginAccount,
					#[codec(index = 2)]
					BridgeAlreadyExists,
					#[codec(index = 3)]
					TooManyBridgesForLocalOrigin,
					#[codec(index = 4)]
					BridgeAlreadyClosed,
					#[codec(index = 5)]
					LanesManager(
						runtime_types::pallet_bridge_messages::lanes_manager::LanesManagerError,
					),
					#[codec(index = 6)]
					UnknownBridge,
					#[codec(index = 7)]
					FailedToReserveBridgeDeposit,
					#[codec(index = 8)]
					UnsupportedXcmVersion,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					BridgeOpened {
						bridge_id: runtime_types::bp_xcm_bridge::BridgeId,
						bridge_deposit: ::core::option::Option<
							runtime_types::bp_xcm_bridge::Deposit<
								::sp_core::crypto::AccountId32,
								::core::primitive::u128,
							>,
						>,
						local_endpoint: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::junctions::Junctions,
						>,
						remote_endpoint: ::subxt::ext::subxt_core::alloc::boxed::Box<
							runtime_types::staging_xcm::v5::junctions::Junctions,
						>,
						lane_id: runtime_types::bp_messages::lane::HashedLaneId,
					},
					#[codec(index = 1)]
					ClosingBridge {
						bridge_id: runtime_types::bp_xcm_bridge::BridgeId,
						lane_id: runtime_types::bp_messages::lane::HashedLaneId,
						pruned_messages: ::core::primitive::u64,
						enqueued_messages: ::core::primitive::u64,
					},
					#[codec(index = 2)]
					BridgePruned {
						bridge_id: runtime_types::bp_xcm_bridge::BridgeId,
						lane_id: runtime_types::bp_messages::lane::HashedLaneId,
						bridge_deposit: ::core::option::Option<
							runtime_types::bp_xcm_bridge::Deposit<
								::sp_core::crypto::AccountId32,
								::core::primitive::u128,
							>,
						>,
						pruned_messages: ::core::primitive::u64,
					},
					#[codec(index = 3)]
					NotificationReceiverUpdated {
						bridge_id: runtime_types::bp_xcm_bridge::BridgeId,
						maybe_notify:
							::core::option::Option<runtime_types::bp_xcm_bridge::Receiver>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum HoldReason {
					#[codec(index = 0)]
					BridgeDeposit,
				}
			}
		}
		pub mod pallet_xcm_bridge_router {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					update_bridge_status {
						bridge_id: runtime_types::bp_xcm_bridge::BridgeId,
						is_congested: ::core::primitive::bool,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					DeliveryFeeFactorDecreased {
						previous_value: runtime_types::sp_arithmetic::fixed_point::FixedU128,
						new_value: runtime_types::sp_arithmetic::fixed_point::FixedU128,
						bridge_id: runtime_types::bp_xcm_bridge::BridgeId,
					},
					#[codec(index = 1)]
					DeliveryFeeFactorIncreased {
						previous_value: runtime_types::sp_arithmetic::fixed_point::FixedU128,
						new_value: runtime_types::sp_arithmetic::fixed_point::FixedU128,
						bridge_id: runtime_types::bp_xcm_bridge::BridgeId,
					},
				}
			}
		}
		pub mod polkadot_core_primitives {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct InboundDownwardMessage<_0> {
				pub sent_at: _0,
				pub msg: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct InboundHrmpMessage<_0> {
				pub sent_at: _0,
				pub data: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct OutboundHrmpMessage<_0> {
				pub recipient: _0,
				pub data: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
			}
		}
		pub mod polkadot_parachain_primitives {
			use super::runtime_types;
			pub mod primitives {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct HeadData(
					pub ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
				);
				#[derive(
					::codec::Decode,
					::codec::Encode,
					::subxt::ext::subxt_core::ext::codec::CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct Id(pub ::core::primitive::u32);
			}
		}
		pub mod polkadot_primitives {
			use super::runtime_types;
			pub mod v8 {
				use super::runtime_types;
				pub mod async_backing {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct AsyncBackingParams {
						pub max_candidate_depth: ::core::primitive::u32,
						pub allowed_ancestry_len: ::core::primitive::u32,
					}
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct AbridgedHostConfiguration {
					pub max_code_size: ::core::primitive::u32,
					pub max_head_data_size: ::core::primitive::u32,
					pub max_upward_queue_count: ::core::primitive::u32,
					pub max_upward_queue_size: ::core::primitive::u32,
					pub max_upward_message_size: ::core::primitive::u32,
					pub max_upward_message_num_per_candidate: ::core::primitive::u32,
					pub hrmp_max_message_num_per_candidate: ::core::primitive::u32,
					pub validation_upgrade_cooldown: ::core::primitive::u32,
					pub validation_upgrade_delay: ::core::primitive::u32,
					pub async_backing_params:
						runtime_types::polkadot_primitives::v8::async_backing::AsyncBackingParams,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct AbridgedHrmpChannel {
					pub max_capacity: ::core::primitive::u32,
					pub max_total_size: ::core::primitive::u32,
					pub max_message_size: ::core::primitive::u32,
					pub msg_count: ::core::primitive::u32,
					pub total_size: ::core::primitive::u32,
					pub mqc_head: ::core::option::Option<::subxt::ext::subxt_core::utils::H256>,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct PersistedValidationData<_0, _1> {
					pub parent_head:
						runtime_types::polkadot_parachain_primitives::primitives::HeadData,
					pub relay_parent_number: _1,
					pub relay_parent_storage_root: _0,
					pub max_pov_size: ::core::primitive::u32,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum UpgradeGoAhead {
					#[codec(index = 0)]
					Abort,
					#[codec(index = 1)]
					GoAhead,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum UpgradeRestriction {
					#[codec(index = 0)]
					Present,
				}
			}
		}
		pub mod sp_arithmetic {
			use super::runtime_types;
			pub mod fixed_point {
				use super::runtime_types;
				#[derive(
					::codec::Decode,
					::codec::Encode,
					::subxt::ext::subxt_core::ext::codec::CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct FixedU128(pub ::core::primitive::u128);
			}
			pub mod per_things {
				use super::runtime_types;
				#[derive(
					::codec::Decode,
					::codec::Encode,
					::subxt::ext::subxt_core::ext::codec::CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct Permill(pub ::core::primitive::u32);
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum ArithmeticError {
				#[codec(index = 0)]
				Underflow,
				#[codec(index = 1)]
				Overflow,
				#[codec(index = 2)]
				DivisionByZero,
			}
		}
		pub mod sp_consensus_aura {
			use super::runtime_types;
			pub mod sr25519 {
				use super::runtime_types;
				pub mod app_sr25519 {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct Public(pub [::core::primitive::u8; 32usize]);
				}
			}
		}
		pub mod sp_consensus_slots {
			use super::runtime_types;
			#[derive(
				::codec::Decode,
				::codec::Encode,
				::subxt::ext::subxt_core::ext::codec::CompactAs,
				Clone,
				Debug,
				PartialEq,
			)]
			pub struct Slot(pub ::core::primitive::u64);
		}
		pub mod sp_core {
			use super::runtime_types;
			pub mod crypto {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct KeyTypeId(pub [::core::primitive::u8; 4usize]);
			}
		}
		pub mod sp_runtime {
			use super::runtime_types;
			pub mod generic {
				use super::runtime_types;
				pub mod digest {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum DigestItem {
						#[codec(index = 6)]
						PreRuntime(
							[::core::primitive::u8; 4usize],
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 4)]
						Consensus(
							[::core::primitive::u8; 4usize],
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 5)]
						Seal(
							[::core::primitive::u8; 4usize],
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 0)]
						Other(::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>),
						#[codec(index = 8)]
						RuntimeEnvironmentUpdated,
					}
				}
			}
			pub mod proving_trie {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum TrieError {
					#[codec(index = 0)]
					InvalidStateRoot,
					#[codec(index = 1)]
					IncompleteDatabase,
					#[codec(index = 2)]
					ValueAtIncompleteKey,
					#[codec(index = 3)]
					DecoderError,
					#[codec(index = 4)]
					InvalidHash,
					#[codec(index = 5)]
					DuplicateKey,
					#[codec(index = 6)]
					ExtraneousNode,
					#[codec(index = 7)]
					ExtraneousValue,
					#[codec(index = 8)]
					ExtraneousHashReference,
					#[codec(index = 9)]
					InvalidChildReference,
					#[codec(index = 10)]
					ValueMismatch,
					#[codec(index = 11)]
					IncompleteProof,
					#[codec(index = 12)]
					RootMismatch,
					#[codec(index = 13)]
					DecodeError,
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum DispatchError {
				#[codec(index = 0)]
				Other,
				#[codec(index = 1)]
				CannotLookup,
				#[codec(index = 2)]
				BadOrigin,
				#[codec(index = 3)]
				Module(runtime_types::sp_runtime::ModuleError),
				#[codec(index = 4)]
				ConsumerRemaining,
				#[codec(index = 5)]
				NoProviders,
				#[codec(index = 6)]
				TooManyConsumers,
				#[codec(index = 7)]
				Token(runtime_types::sp_runtime::TokenError),
				#[codec(index = 8)]
				Arithmetic(runtime_types::sp_arithmetic::ArithmeticError),
				#[codec(index = 9)]
				Transactional(runtime_types::sp_runtime::TransactionalError),
				#[codec(index = 10)]
				Exhausted,
				#[codec(index = 11)]
				Corruption,
				#[codec(index = 12)]
				Unavailable,
				#[codec(index = 13)]
				RootNotAllowed,
				#[codec(index = 14)]
				Trie(runtime_types::sp_runtime::proving_trie::TrieError),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct ModuleError {
				pub index: ::core::primitive::u8,
				pub error: [::core::primitive::u8; 4usize],
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum MultiSignature {
				#[codec(index = 0)]
				Ed25519([::core::primitive::u8; 64usize]),
				#[codec(index = 1)]
				Sr25519([::core::primitive::u8; 64usize]),
				#[codec(index = 2)]
				Ecdsa([::core::primitive::u8; 65usize]),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum TokenError {
				#[codec(index = 0)]
				FundsUnavailable,
				#[codec(index = 1)]
				OnlyProvider,
				#[codec(index = 2)]
				BelowMinimum,
				#[codec(index = 3)]
				CannotCreate,
				#[codec(index = 4)]
				UnknownAsset,
				#[codec(index = 5)]
				Frozen,
				#[codec(index = 6)]
				Unsupported,
				#[codec(index = 7)]
				CannotCreateHold,
				#[codec(index = 8)]
				NotExpendable,
				#[codec(index = 9)]
				Blocked,
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum TransactionalError {
				#[codec(index = 0)]
				LimitReached,
				#[codec(index = 1)]
				NoLayer,
			}
		}
		pub mod sp_trie {
			use super::runtime_types;
			pub mod storage_proof {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct StorageProof {
					pub trie_nodes: ::subxt::ext::subxt_core::alloc::vec::Vec<
						::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
					>,
				}
			}
		}
		pub mod sp_version {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct RuntimeVersion {
				pub spec_name: ::subxt::ext::subxt_core::alloc::string::String,
				pub impl_name: ::subxt::ext::subxt_core::alloc::string::String,
				pub authoring_version: ::core::primitive::u32,
				pub spec_version: ::core::primitive::u32,
				pub impl_version: ::core::primitive::u32,
				pub apis: ::subxt::ext::subxt_core::alloc::vec::Vec<(
					[::core::primitive::u8; 8usize],
					::core::primitive::u32,
				)>,
				pub transaction_version: ::core::primitive::u32,
				pub system_version: ::core::primitive::u8,
			}
		}
		pub mod sp_weights {
			use super::runtime_types;
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub struct RuntimeDbWeight {
				pub read: ::core::primitive::u64,
				pub write: ::core::primitive::u64,
			}
		}
		pub mod staging_parachain_info {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Call {}
			}
		}
		pub mod staging_xcm {
			use super::runtime_types;
			pub mod v3 {
				use super::runtime_types;
				pub mod multilocation {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct MultiLocation {
						pub parents: ::core::primitive::u8,
						pub interior: runtime_types::xcm::v3::junctions::Junctions,
					}
				}
			}
			pub mod v4 {
				use super::runtime_types;
				pub mod asset {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct Asset {
						pub id: runtime_types::staging_xcm::v4::asset::AssetId,
						pub fun: runtime_types::staging_xcm::v4::asset::Fungibility,
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum AssetFilter {
						#[codec(index = 0)]
						Definite(runtime_types::staging_xcm::v4::asset::Assets),
						#[codec(index = 1)]
						Wild(runtime_types::staging_xcm::v4::asset::WildAsset),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct AssetId(pub runtime_types::staging_xcm::v4::location::Location);
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum AssetInstance {
						#[codec(index = 0)]
						Undefined,
						#[codec(index = 1)]
						Index(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 2)]
						Array4([::core::primitive::u8; 4usize]),
						#[codec(index = 3)]
						Array8([::core::primitive::u8; 8usize]),
						#[codec(index = 4)]
						Array16([::core::primitive::u8; 16usize]),
						#[codec(index = 5)]
						Array32([::core::primitive::u8; 32usize]),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct Assets(
						pub  ::subxt::ext::subxt_core::alloc::vec::Vec<
							runtime_types::staging_xcm::v4::asset::Asset,
						>,
					);
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Fungibility {
						#[codec(index = 0)]
						Fungible(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 1)]
						NonFungible(runtime_types::staging_xcm::v4::asset::AssetInstance),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum WildAsset {
						#[codec(index = 0)]
						All,
						#[codec(index = 1)]
						AllOf {
							id: runtime_types::staging_xcm::v4::asset::AssetId,
							fun: runtime_types::staging_xcm::v4::asset::WildFungibility,
						},
						#[codec(index = 2)]
						AllCounted(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 3)]
						AllOfCounted {
							id: runtime_types::staging_xcm::v4::asset::AssetId,
							fun: runtime_types::staging_xcm::v4::asset::WildFungibility,
							#[codec(compact)]
							count: ::core::primitive::u32,
						},
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum WildFungibility {
						#[codec(index = 0)]
						Fungible,
						#[codec(index = 1)]
						NonFungible,
					}
				}
				pub mod junction {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Junction {
						#[codec(index = 0)]
						Parachain(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 1)]
						AccountId32 {
							network: ::core::option::Option<
								runtime_types::staging_xcm::v4::junction::NetworkId,
							>,
							id: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						AccountIndex64 {
							network: ::core::option::Option<
								runtime_types::staging_xcm::v4::junction::NetworkId,
							>,
							#[codec(compact)]
							index: ::core::primitive::u64,
						},
						#[codec(index = 3)]
						AccountKey20 {
							network: ::core::option::Option<
								runtime_types::staging_xcm::v4::junction::NetworkId,
							>,
							key: [::core::primitive::u8; 20usize],
						},
						#[codec(index = 4)]
						PalletInstance(::core::primitive::u8),
						#[codec(index = 5)]
						GeneralIndex(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 6)]
						GeneralKey {
							length: ::core::primitive::u8,
							data: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 7)]
						OnlyChild,
						#[codec(index = 8)]
						Plurality {
							id: runtime_types::xcm::v3::junction::BodyId,
							part: runtime_types::xcm::v3::junction::BodyPart,
						},
						#[codec(index = 9)]
						GlobalConsensus(runtime_types::staging_xcm::v4::junction::NetworkId),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum NetworkId {
						#[codec(index = 0)]
						ByGenesis([::core::primitive::u8; 32usize]),
						#[codec(index = 1)]
						ByFork {
							block_number: ::core::primitive::u64,
							block_hash: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						Polkadot,
						#[codec(index = 3)]
						Kusama,
						#[codec(index = 4)]
						Westend,
						#[codec(index = 5)]
						Rococo,
						#[codec(index = 6)]
						Wococo,
						#[codec(index = 7)]
						Ethereum {
							#[codec(compact)]
							chain_id: ::core::primitive::u64,
						},
						#[codec(index = 8)]
						BitcoinCore,
						#[codec(index = 9)]
						BitcoinCash,
						#[codec(index = 10)]
						PolkadotBulletin,
					}
				}
				pub mod junctions {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Junctions {
						#[codec(index = 0)]
						Here,
						#[codec(index = 1)]
						X1([runtime_types::staging_xcm::v4::junction::Junction; 1usize]),
						#[codec(index = 2)]
						X2([runtime_types::staging_xcm::v4::junction::Junction; 2usize]),
						#[codec(index = 3)]
						X3([runtime_types::staging_xcm::v4::junction::Junction; 3usize]),
						#[codec(index = 4)]
						X4([runtime_types::staging_xcm::v4::junction::Junction; 4usize]),
						#[codec(index = 5)]
						X5([runtime_types::staging_xcm::v4::junction::Junction; 5usize]),
						#[codec(index = 6)]
						X6([runtime_types::staging_xcm::v4::junction::Junction; 6usize]),
						#[codec(index = 7)]
						X7([runtime_types::staging_xcm::v4::junction::Junction; 7usize]),
						#[codec(index = 8)]
						X8([runtime_types::staging_xcm::v4::junction::Junction; 8usize]),
					}
				}
				pub mod location {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct Location {
						pub parents: ::core::primitive::u8,
						pub interior: runtime_types::staging_xcm::v4::junctions::Junctions,
					}
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Instruction {
					#[codec(index = 0)]
					WithdrawAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 1)]
					ReserveAssetDeposited(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 2)]
					ReceiveTeleportedAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 3)]
					QueryResponse {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						response: runtime_types::staging_xcm::v4::Response,
						max_weight: ::sp_weights::Weight,
						querier: ::core::option::Option<
							runtime_types::staging_xcm::v4::location::Location,
						>,
					},
					#[codec(index = 4)]
					TransferAsset {
						assets: runtime_types::staging_xcm::v4::asset::Assets,
						beneficiary: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 5)]
					TransferReserveAsset {
						assets: runtime_types::staging_xcm::v4::asset::Assets,
						dest: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 6)]
					Transact {
						origin_kind: runtime_types::xcm::v3::OriginKind,
						require_weight_at_most: ::sp_weights::Weight,
						call: runtime_types::xcm::double_encoded::DoubleEncoded,
					},
					#[codec(index = 7)]
					HrmpNewChannelOpenRequest {
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						max_message_size: ::core::primitive::u32,
						#[codec(compact)]
						max_capacity: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					HrmpChannelAccepted {
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 9)]
					HrmpChannelClosing {
						#[codec(compact)]
						initiator: ::core::primitive::u32,
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 10)]
					ClearOrigin,
					#[codec(index = 11)]
					DescendOrigin(runtime_types::staging_xcm::v4::junctions::Junctions),
					#[codec(index = 12)]
					ReportError(runtime_types::staging_xcm::v4::QueryResponseInfo),
					#[codec(index = 13)]
					DepositAsset {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						beneficiary: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 14)]
					DepositReserveAsset {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						dest: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 15)]
					ExchangeAsset {
						give: runtime_types::staging_xcm::v4::asset::AssetFilter,
						want: runtime_types::staging_xcm::v4::asset::Assets,
						maximal: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					InitiateReserveWithdraw {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						reserve: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 17)]
					InitiateTeleport {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						dest: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 18)]
					ReportHolding {
						response_info: runtime_types::staging_xcm::v4::QueryResponseInfo,
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
					},
					#[codec(index = 19)]
					BuyExecution {
						fees: runtime_types::staging_xcm::v4::asset::Asset,
						weight_limit: runtime_types::xcm::v3::WeightLimit,
					},
					#[codec(index = 20)]
					RefundSurplus,
					#[codec(index = 21)]
					SetErrorHandler(runtime_types::staging_xcm::v4::Xcm),
					#[codec(index = 22)]
					SetAppendix(runtime_types::staging_xcm::v4::Xcm),
					#[codec(index = 23)]
					ClearError,
					#[codec(index = 24)]
					ClaimAsset {
						assets: runtime_types::staging_xcm::v4::asset::Assets,
						ticket: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 25)]
					Trap(#[codec(compact)] ::core::primitive::u64),
					#[codec(index = 26)]
					SubscribeVersion {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						max_response_weight: ::sp_weights::Weight,
					},
					#[codec(index = 27)]
					UnsubscribeVersion,
					#[codec(index = 28)]
					BurnAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 29)]
					ExpectAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 30)]
					ExpectOrigin(
						::core::option::Option<runtime_types::staging_xcm::v4::location::Location>,
					),
					#[codec(index = 31)]
					ExpectError(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v3::traits::Error,
						)>,
					),
					#[codec(index = 32)]
					ExpectTransactStatus(runtime_types::xcm::v3::MaybeErrorCode),
					#[codec(index = 33)]
					QueryPallet {
						module_name:
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						response_info: runtime_types::staging_xcm::v4::QueryResponseInfo,
					},
					#[codec(index = 34)]
					ExpectPallet {
						#[codec(compact)]
						index: ::core::primitive::u32,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						module_name:
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						#[codec(compact)]
						crate_major: ::core::primitive::u32,
						#[codec(compact)]
						min_crate_minor: ::core::primitive::u32,
					},
					#[codec(index = 35)]
					ReportTransactStatus(runtime_types::staging_xcm::v4::QueryResponseInfo),
					#[codec(index = 36)]
					ClearTransactStatus,
					#[codec(index = 37)]
					UniversalOrigin(runtime_types::staging_xcm::v4::junction::Junction),
					#[codec(index = 38)]
					ExportMessage {
						network: runtime_types::staging_xcm::v4::junction::NetworkId,
						destination: runtime_types::staging_xcm::v4::junctions::Junctions,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 39)]
					LockAsset {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						unlocker: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 40)]
					UnlockAsset {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						target: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 41)]
					NoteUnlockable {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						owner: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 42)]
					RequestUnlock {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						locker: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 43)]
					SetFeesMode { jit_withdraw: ::core::primitive::bool },
					#[codec(index = 44)]
					SetTopic([::core::primitive::u8; 32usize]),
					#[codec(index = 45)]
					ClearTopic,
					#[codec(index = 46)]
					AliasOrigin(runtime_types::staging_xcm::v4::location::Location),
					#[codec(index = 47)]
					UnpaidExecution {
						weight_limit: runtime_types::xcm::v3::WeightLimit,
						check_origin: ::core::option::Option<
							runtime_types::staging_xcm::v4::location::Location,
						>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct PalletInfo {
					#[codec(compact)]
					pub index: ::core::primitive::u32,
					pub name: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					pub module_name: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					#[codec(compact)]
					pub major: ::core::primitive::u32,
					#[codec(compact)]
					pub minor: ::core::primitive::u32,
					#[codec(compact)]
					pub patch: ::core::primitive::u32,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct QueryResponseInfo {
					pub destination: runtime_types::staging_xcm::v4::location::Location,
					#[codec(compact)]
					pub query_id: ::core::primitive::u64,
					pub max_weight: ::sp_weights::Weight,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Response {
					#[codec(index = 0)]
					Null,
					#[codec(index = 1)]
					Assets(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 2)]
					ExecutionResult(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v3::traits::Error,
						)>,
					),
					#[codec(index = 3)]
					Version(::core::primitive::u32),
					#[codec(index = 4)]
					PalletsInfo(
						runtime_types::bounded_collections::bounded_vec::BoundedVec<
							runtime_types::staging_xcm::v4::PalletInfo,
						>,
					),
					#[codec(index = 5)]
					DispatchResult(runtime_types::xcm::v3::MaybeErrorCode),
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct Xcm(
					pub  ::subxt::ext::subxt_core::alloc::vec::Vec<
						runtime_types::staging_xcm::v4::Instruction,
					>,
				);
			}
			pub mod v5 {
				use super::runtime_types;
				pub mod asset {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct Asset {
						pub id: runtime_types::staging_xcm::v5::asset::AssetId,
						pub fun: runtime_types::staging_xcm::v5::asset::Fungibility,
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum AssetFilter {
						#[codec(index = 0)]
						Definite(runtime_types::staging_xcm::v5::asset::Assets),
						#[codec(index = 1)]
						Wild(runtime_types::staging_xcm::v5::asset::WildAsset),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct AssetId(pub runtime_types::staging_xcm::v5::location::Location);
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum AssetInstance {
						#[codec(index = 0)]
						Undefined,
						#[codec(index = 1)]
						Index(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 2)]
						Array4([::core::primitive::u8; 4usize]),
						#[codec(index = 3)]
						Array8([::core::primitive::u8; 8usize]),
						#[codec(index = 4)]
						Array16([::core::primitive::u8; 16usize]),
						#[codec(index = 5)]
						Array32([::core::primitive::u8; 32usize]),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum AssetTransferFilter {
						#[codec(index = 0)]
						Teleport(runtime_types::staging_xcm::v5::asset::AssetFilter),
						#[codec(index = 1)]
						ReserveDeposit(runtime_types::staging_xcm::v5::asset::AssetFilter),
						#[codec(index = 2)]
						ReserveWithdraw(runtime_types::staging_xcm::v5::asset::AssetFilter),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct Assets(
						pub  ::subxt::ext::subxt_core::alloc::vec::Vec<
							runtime_types::staging_xcm::v5::asset::Asset,
						>,
					);
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Fungibility {
						#[codec(index = 0)]
						Fungible(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 1)]
						NonFungible(runtime_types::staging_xcm::v5::asset::AssetInstance),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum WildAsset {
						#[codec(index = 0)]
						All,
						#[codec(index = 1)]
						AllOf {
							id: runtime_types::staging_xcm::v5::asset::AssetId,
							fun: runtime_types::staging_xcm::v5::asset::WildFungibility,
						},
						#[codec(index = 2)]
						AllCounted(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 3)]
						AllOfCounted {
							id: runtime_types::staging_xcm::v5::asset::AssetId,
							fun: runtime_types::staging_xcm::v5::asset::WildFungibility,
							#[codec(compact)]
							count: ::core::primitive::u32,
						},
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum WildFungibility {
						#[codec(index = 0)]
						Fungible,
						#[codec(index = 1)]
						NonFungible,
					}
				}
				pub mod junction {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Junction {
						#[codec(index = 0)]
						Parachain(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 1)]
						AccountId32 {
							network: ::core::option::Option<
								runtime_types::staging_xcm::v5::junction::NetworkId,
							>,
							id: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						AccountIndex64 {
							network: ::core::option::Option<
								runtime_types::staging_xcm::v5::junction::NetworkId,
							>,
							#[codec(compact)]
							index: ::core::primitive::u64,
						},
						#[codec(index = 3)]
						AccountKey20 {
							network: ::core::option::Option<
								runtime_types::staging_xcm::v5::junction::NetworkId,
							>,
							key: [::core::primitive::u8; 20usize],
						},
						#[codec(index = 4)]
						PalletInstance(::core::primitive::u8),
						#[codec(index = 5)]
						GeneralIndex(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 6)]
						GeneralKey {
							length: ::core::primitive::u8,
							data: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 7)]
						OnlyChild,
						#[codec(index = 8)]
						Plurality {
							id: runtime_types::xcm::v3::junction::BodyId,
							part: runtime_types::xcm::v3::junction::BodyPart,
						},
						#[codec(index = 9)]
						GlobalConsensus(runtime_types::staging_xcm::v5::junction::NetworkId),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum NetworkId {
						#[codec(index = 0)]
						ByGenesis([::core::primitive::u8; 32usize]),
						#[codec(index = 1)]
						ByFork {
							block_number: ::core::primitive::u64,
							block_hash: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						Polkadot,
						#[codec(index = 3)]
						Kusama,
						#[codec(index = 7)]
						Ethereum {
							#[codec(compact)]
							chain_id: ::core::primitive::u64,
						},
						#[codec(index = 8)]
						BitcoinCore,
						#[codec(index = 9)]
						BitcoinCash,
						#[codec(index = 10)]
						PolkadotBulletin,
					}
				}
				pub mod junctions {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Junctions {
						#[codec(index = 0)]
						Here,
						#[codec(index = 1)]
						X1([runtime_types::staging_xcm::v5::junction::Junction; 1usize]),
						#[codec(index = 2)]
						X2([runtime_types::staging_xcm::v5::junction::Junction; 2usize]),
						#[codec(index = 3)]
						X3([runtime_types::staging_xcm::v5::junction::Junction; 3usize]),
						#[codec(index = 4)]
						X4([runtime_types::staging_xcm::v5::junction::Junction; 4usize]),
						#[codec(index = 5)]
						X5([runtime_types::staging_xcm::v5::junction::Junction; 5usize]),
						#[codec(index = 6)]
						X6([runtime_types::staging_xcm::v5::junction::Junction; 6usize]),
						#[codec(index = 7)]
						X7([runtime_types::staging_xcm::v5::junction::Junction; 7usize]),
						#[codec(index = 8)]
						X8([runtime_types::staging_xcm::v5::junction::Junction; 8usize]),
					}
				}
				pub mod location {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct Location {
						pub parents: ::core::primitive::u8,
						pub interior: runtime_types::staging_xcm::v5::junctions::Junctions,
					}
				}
				pub mod traits {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Outcome {
						#[codec(index = 0)]
						Complete { used: ::sp_weights::Weight },
						#[codec(index = 1)]
						Incomplete {
							used: ::sp_weights::Weight,
							error: runtime_types::xcm::v5::traits::Error,
						},
						#[codec(index = 2)]
						Error { error: runtime_types::xcm::v5::traits::Error },
					}
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Hint {
					#[codec(index = 0)]
					AssetClaimer { location: runtime_types::staging_xcm::v5::location::Location },
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Instruction {
					#[codec(index = 0)]
					WithdrawAsset(runtime_types::staging_xcm::v5::asset::Assets),
					#[codec(index = 1)]
					ReserveAssetDeposited(runtime_types::staging_xcm::v5::asset::Assets),
					#[codec(index = 2)]
					ReceiveTeleportedAsset(runtime_types::staging_xcm::v5::asset::Assets),
					#[codec(index = 3)]
					QueryResponse {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						response: runtime_types::staging_xcm::v5::Response,
						max_weight: ::sp_weights::Weight,
						querier: ::core::option::Option<
							runtime_types::staging_xcm::v5::location::Location,
						>,
					},
					#[codec(index = 4)]
					TransferAsset {
						assets: runtime_types::staging_xcm::v5::asset::Assets,
						beneficiary: runtime_types::staging_xcm::v5::location::Location,
					},
					#[codec(index = 5)]
					TransferReserveAsset {
						assets: runtime_types::staging_xcm::v5::asset::Assets,
						dest: runtime_types::staging_xcm::v5::location::Location,
						xcm: runtime_types::staging_xcm::v5::Xcm,
					},
					#[codec(index = 6)]
					Transact {
						origin_kind: runtime_types::xcm::v3::OriginKind,
						fallback_max_weight: ::core::option::Option<::sp_weights::Weight>,
						call: runtime_types::xcm::double_encoded::DoubleEncoded,
					},
					#[codec(index = 7)]
					HrmpNewChannelOpenRequest {
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						max_message_size: ::core::primitive::u32,
						#[codec(compact)]
						max_capacity: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					HrmpChannelAccepted {
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 9)]
					HrmpChannelClosing {
						#[codec(compact)]
						initiator: ::core::primitive::u32,
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 10)]
					ClearOrigin,
					#[codec(index = 11)]
					DescendOrigin(runtime_types::staging_xcm::v5::junctions::Junctions),
					#[codec(index = 12)]
					ReportError(runtime_types::staging_xcm::v5::QueryResponseInfo),
					#[codec(index = 13)]
					DepositAsset {
						assets: runtime_types::staging_xcm::v5::asset::AssetFilter,
						beneficiary: runtime_types::staging_xcm::v5::location::Location,
					},
					#[codec(index = 14)]
					DepositReserveAsset {
						assets: runtime_types::staging_xcm::v5::asset::AssetFilter,
						dest: runtime_types::staging_xcm::v5::location::Location,
						xcm: runtime_types::staging_xcm::v5::Xcm,
					},
					#[codec(index = 15)]
					ExchangeAsset {
						give: runtime_types::staging_xcm::v5::asset::AssetFilter,
						want: runtime_types::staging_xcm::v5::asset::Assets,
						maximal: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					InitiateReserveWithdraw {
						assets: runtime_types::staging_xcm::v5::asset::AssetFilter,
						reserve: runtime_types::staging_xcm::v5::location::Location,
						xcm: runtime_types::staging_xcm::v5::Xcm,
					},
					#[codec(index = 17)]
					InitiateTeleport {
						assets: runtime_types::staging_xcm::v5::asset::AssetFilter,
						dest: runtime_types::staging_xcm::v5::location::Location,
						xcm: runtime_types::staging_xcm::v5::Xcm,
					},
					#[codec(index = 18)]
					ReportHolding {
						response_info: runtime_types::staging_xcm::v5::QueryResponseInfo,
						assets: runtime_types::staging_xcm::v5::asset::AssetFilter,
					},
					#[codec(index = 19)]
					BuyExecution {
						fees: runtime_types::staging_xcm::v5::asset::Asset,
						weight_limit: runtime_types::xcm::v3::WeightLimit,
					},
					#[codec(index = 20)]
					RefundSurplus,
					#[codec(index = 21)]
					SetErrorHandler(runtime_types::staging_xcm::v5::Xcm),
					#[codec(index = 22)]
					SetAppendix(runtime_types::staging_xcm::v5::Xcm),
					#[codec(index = 23)]
					ClearError,
					#[codec(index = 24)]
					ClaimAsset {
						assets: runtime_types::staging_xcm::v5::asset::Assets,
						ticket: runtime_types::staging_xcm::v5::location::Location,
					},
					#[codec(index = 25)]
					Trap(#[codec(compact)] ::core::primitive::u64),
					#[codec(index = 26)]
					SubscribeVersion {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						max_response_weight: ::sp_weights::Weight,
					},
					#[codec(index = 27)]
					UnsubscribeVersion,
					#[codec(index = 28)]
					BurnAsset(runtime_types::staging_xcm::v5::asset::Assets),
					#[codec(index = 29)]
					ExpectAsset(runtime_types::staging_xcm::v5::asset::Assets),
					#[codec(index = 30)]
					ExpectOrigin(
						::core::option::Option<runtime_types::staging_xcm::v5::location::Location>,
					),
					#[codec(index = 31)]
					ExpectError(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v5::traits::Error,
						)>,
					),
					#[codec(index = 32)]
					ExpectTransactStatus(runtime_types::xcm::v3::MaybeErrorCode),
					#[codec(index = 33)]
					QueryPallet {
						module_name:
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						response_info: runtime_types::staging_xcm::v5::QueryResponseInfo,
					},
					#[codec(index = 34)]
					ExpectPallet {
						#[codec(compact)]
						index: ::core::primitive::u32,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						module_name:
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						#[codec(compact)]
						crate_major: ::core::primitive::u32,
						#[codec(compact)]
						min_crate_minor: ::core::primitive::u32,
					},
					#[codec(index = 35)]
					ReportTransactStatus(runtime_types::staging_xcm::v5::QueryResponseInfo),
					#[codec(index = 36)]
					ClearTransactStatus,
					#[codec(index = 37)]
					UniversalOrigin(runtime_types::staging_xcm::v5::junction::Junction),
					#[codec(index = 38)]
					ExportMessage {
						network: runtime_types::staging_xcm::v5::junction::NetworkId,
						destination: runtime_types::staging_xcm::v5::junctions::Junctions,
						xcm: runtime_types::staging_xcm::v5::Xcm,
					},
					#[codec(index = 39)]
					LockAsset {
						asset: runtime_types::staging_xcm::v5::asset::Asset,
						unlocker: runtime_types::staging_xcm::v5::location::Location,
					},
					#[codec(index = 40)]
					UnlockAsset {
						asset: runtime_types::staging_xcm::v5::asset::Asset,
						target: runtime_types::staging_xcm::v5::location::Location,
					},
					#[codec(index = 41)]
					NoteUnlockable {
						asset: runtime_types::staging_xcm::v5::asset::Asset,
						owner: runtime_types::staging_xcm::v5::location::Location,
					},
					#[codec(index = 42)]
					RequestUnlock {
						asset: runtime_types::staging_xcm::v5::asset::Asset,
						locker: runtime_types::staging_xcm::v5::location::Location,
					},
					#[codec(index = 43)]
					SetFeesMode { jit_withdraw: ::core::primitive::bool },
					#[codec(index = 44)]
					SetTopic([::core::primitive::u8; 32usize]),
					#[codec(index = 45)]
					ClearTopic,
					#[codec(index = 46)]
					AliasOrigin(runtime_types::staging_xcm::v5::location::Location),
					#[codec(index = 47)]
					UnpaidExecution {
						weight_limit: runtime_types::xcm::v3::WeightLimit,
						check_origin: ::core::option::Option<
							runtime_types::staging_xcm::v5::location::Location,
						>,
					},
					#[codec(index = 48)]
					PayFees { asset: runtime_types::staging_xcm::v5::asset::Asset },
					#[codec(index = 49)]
					InitiateTransfer {
						destination: runtime_types::staging_xcm::v5::location::Location,
						remote_fees: ::core::option::Option<
							runtime_types::staging_xcm::v5::asset::AssetTransferFilter,
						>,
						preserve_origin: ::core::primitive::bool,
						assets: ::subxt::ext::subxt_core::alloc::vec::Vec<
							runtime_types::staging_xcm::v5::asset::AssetTransferFilter,
						>,
						remote_xcm: runtime_types::staging_xcm::v5::Xcm,
					},
					#[codec(index = 50)]
					ExecuteWithOrigin {
						descendant_origin: ::core::option::Option<
							runtime_types::staging_xcm::v5::junctions::Junctions,
						>,
						xcm: runtime_types::staging_xcm::v5::Xcm,
					},
					#[codec(index = 51)]
					SetHints {
						hints: runtime_types::bounded_collections::bounded_vec::BoundedVec<
							runtime_types::staging_xcm::v5::Hint,
						>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct PalletInfo {
					#[codec(compact)]
					pub index: ::core::primitive::u32,
					pub name: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					pub module_name: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					#[codec(compact)]
					pub major: ::core::primitive::u32,
					#[codec(compact)]
					pub minor: ::core::primitive::u32,
					#[codec(compact)]
					pub patch: ::core::primitive::u32,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct QueryResponseInfo {
					pub destination: runtime_types::staging_xcm::v5::location::Location,
					#[codec(compact)]
					pub query_id: ::core::primitive::u64,
					pub max_weight: ::sp_weights::Weight,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Response {
					#[codec(index = 0)]
					Null,
					#[codec(index = 1)]
					Assets(runtime_types::staging_xcm::v5::asset::Assets),
					#[codec(index = 2)]
					ExecutionResult(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v5::traits::Error,
						)>,
					),
					#[codec(index = 3)]
					Version(::core::primitive::u32),
					#[codec(index = 4)]
					PalletsInfo(
						runtime_types::bounded_collections::bounded_vec::BoundedVec<
							runtime_types::staging_xcm::v5::PalletInfo,
						>,
					),
					#[codec(index = 5)]
					DispatchResult(runtime_types::xcm::v3::MaybeErrorCode),
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct Xcm(
					pub  ::subxt::ext::subxt_core::alloc::vec::Vec<
						runtime_types::staging_xcm::v5::Instruction,
					>,
				);
			}
		}
		pub mod staging_xcm_executor {
			use super::runtime_types;
			pub mod traits {
				use super::runtime_types;
				pub mod asset_transfer {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum TransferType {
						#[codec(index = 0)]
						Teleport,
						#[codec(index = 1)]
						LocalReserve,
						#[codec(index = 2)]
						DestinationReserve,
						#[codec(index = 3)]
						RemoteReserve(runtime_types::xcm::VersionedLocation),
					}
				}
			}
		}
		pub mod xcm {
			use super::runtime_types;
			pub mod double_encoded {
				use super::runtime_types;
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct DoubleEncoded {
					pub encoded: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
				}
			}
			pub mod v3 {
				use super::runtime_types;
				pub mod junction {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum BodyId {
						#[codec(index = 0)]
						Unit,
						#[codec(index = 1)]
						Moniker([::core::primitive::u8; 4usize]),
						#[codec(index = 2)]
						Index(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 3)]
						Executive,
						#[codec(index = 4)]
						Technical,
						#[codec(index = 5)]
						Legislative,
						#[codec(index = 6)]
						Judicial,
						#[codec(index = 7)]
						Defense,
						#[codec(index = 8)]
						Administration,
						#[codec(index = 9)]
						Treasury,
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum BodyPart {
						#[codec(index = 0)]
						Voice,
						#[codec(index = 1)]
						Members {
							#[codec(compact)]
							count: ::core::primitive::u32,
						},
						#[codec(index = 2)]
						Fraction {
							#[codec(compact)]
							nom: ::core::primitive::u32,
							#[codec(compact)]
							denom: ::core::primitive::u32,
						},
						#[codec(index = 3)]
						AtLeastProportion {
							#[codec(compact)]
							nom: ::core::primitive::u32,
							#[codec(compact)]
							denom: ::core::primitive::u32,
						},
						#[codec(index = 4)]
						MoreThanProportion {
							#[codec(compact)]
							nom: ::core::primitive::u32,
							#[codec(compact)]
							denom: ::core::primitive::u32,
						},
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Junction {
						#[codec(index = 0)]
						Parachain(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 1)]
						AccountId32 {
							network:
								::core::option::Option<runtime_types::xcm::v3::junction::NetworkId>,
							id: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						AccountIndex64 {
							network:
								::core::option::Option<runtime_types::xcm::v3::junction::NetworkId>,
							#[codec(compact)]
							index: ::core::primitive::u64,
						},
						#[codec(index = 3)]
						AccountKey20 {
							network:
								::core::option::Option<runtime_types::xcm::v3::junction::NetworkId>,
							key: [::core::primitive::u8; 20usize],
						},
						#[codec(index = 4)]
						PalletInstance(::core::primitive::u8),
						#[codec(index = 5)]
						GeneralIndex(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 6)]
						GeneralKey {
							length: ::core::primitive::u8,
							data: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 7)]
						OnlyChild,
						#[codec(index = 8)]
						Plurality {
							id: runtime_types::xcm::v3::junction::BodyId,
							part: runtime_types::xcm::v3::junction::BodyPart,
						},
						#[codec(index = 9)]
						GlobalConsensus(runtime_types::xcm::v3::junction::NetworkId),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum NetworkId {
						#[codec(index = 0)]
						ByGenesis([::core::primitive::u8; 32usize]),
						#[codec(index = 1)]
						ByFork {
							block_number: ::core::primitive::u64,
							block_hash: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						Polkadot,
						#[codec(index = 3)]
						Kusama,
						#[codec(index = 4)]
						Westend,
						#[codec(index = 5)]
						Rococo,
						#[codec(index = 6)]
						Wococo,
						#[codec(index = 7)]
						Ethereum {
							#[codec(compact)]
							chain_id: ::core::primitive::u64,
						},
						#[codec(index = 8)]
						BitcoinCore,
						#[codec(index = 9)]
						BitcoinCash,
						#[codec(index = 10)]
						PolkadotBulletin,
					}
				}
				pub mod junctions {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Junctions {
						#[codec(index = 0)]
						Here,
						#[codec(index = 1)]
						X1(runtime_types::xcm::v3::junction::Junction),
						#[codec(index = 2)]
						X2(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 3)]
						X3(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 4)]
						X4(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 5)]
						X5(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 6)]
						X6(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 7)]
						X7(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 8)]
						X8(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
					}
				}
				pub mod multiasset {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum AssetId {
						#[codec(index = 0)]
						Concrete(runtime_types::staging_xcm::v3::multilocation::MultiLocation),
						#[codec(index = 1)]
						Abstract([::core::primitive::u8; 32usize]),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum AssetInstance {
						#[codec(index = 0)]
						Undefined,
						#[codec(index = 1)]
						Index(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 2)]
						Array4([::core::primitive::u8; 4usize]),
						#[codec(index = 3)]
						Array8([::core::primitive::u8; 8usize]),
						#[codec(index = 4)]
						Array16([::core::primitive::u8; 16usize]),
						#[codec(index = 5)]
						Array32([::core::primitive::u8; 32usize]),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Fungibility {
						#[codec(index = 0)]
						Fungible(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 1)]
						NonFungible(runtime_types::xcm::v3::multiasset::AssetInstance),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct MultiAsset {
						pub id: runtime_types::xcm::v3::multiasset::AssetId,
						pub fun: runtime_types::xcm::v3::multiasset::Fungibility,
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum MultiAssetFilter {
						#[codec(index = 0)]
						Definite(runtime_types::xcm::v3::multiasset::MultiAssets),
						#[codec(index = 1)]
						Wild(runtime_types::xcm::v3::multiasset::WildMultiAsset),
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub struct MultiAssets(
						pub  ::subxt::ext::subxt_core::alloc::vec::Vec<
							runtime_types::xcm::v3::multiasset::MultiAsset,
						>,
					);
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum WildFungibility {
						#[codec(index = 0)]
						Fungible,
						#[codec(index = 1)]
						NonFungible,
					}
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum WildMultiAsset {
						#[codec(index = 0)]
						All,
						#[codec(index = 1)]
						AllOf {
							id: runtime_types::xcm::v3::multiasset::AssetId,
							fun: runtime_types::xcm::v3::multiasset::WildFungibility,
						},
						#[codec(index = 2)]
						AllCounted(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 3)]
						AllOfCounted {
							id: runtime_types::xcm::v3::multiasset::AssetId,
							fun: runtime_types::xcm::v3::multiasset::WildFungibility,
							#[codec(compact)]
							count: ::core::primitive::u32,
						},
					}
				}
				pub mod traits {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Error {
						#[codec(index = 0)]
						Overflow,
						#[codec(index = 1)]
						Unimplemented,
						#[codec(index = 2)]
						UntrustedReserveLocation,
						#[codec(index = 3)]
						UntrustedTeleportLocation,
						#[codec(index = 4)]
						LocationFull,
						#[codec(index = 5)]
						LocationNotInvertible,
						#[codec(index = 6)]
						BadOrigin,
						#[codec(index = 7)]
						InvalidLocation,
						#[codec(index = 8)]
						AssetNotFound,
						#[codec(index = 9)]
						FailedToTransactAsset,
						#[codec(index = 10)]
						NotWithdrawable,
						#[codec(index = 11)]
						LocationCannotHold,
						#[codec(index = 12)]
						ExceedsMaxMessageSize,
						#[codec(index = 13)]
						DestinationUnsupported,
						#[codec(index = 14)]
						Transport,
						#[codec(index = 15)]
						Unroutable,
						#[codec(index = 16)]
						UnknownClaim,
						#[codec(index = 17)]
						FailedToDecode,
						#[codec(index = 18)]
						MaxWeightInvalid,
						#[codec(index = 19)]
						NotHoldingFees,
						#[codec(index = 20)]
						TooExpensive,
						#[codec(index = 21)]
						Trap(::core::primitive::u64),
						#[codec(index = 22)]
						ExpectationFalse,
						#[codec(index = 23)]
						PalletNotFound,
						#[codec(index = 24)]
						NameMismatch,
						#[codec(index = 25)]
						VersionIncompatible,
						#[codec(index = 26)]
						HoldingWouldOverflow,
						#[codec(index = 27)]
						ExportError,
						#[codec(index = 28)]
						ReanchorFailed,
						#[codec(index = 29)]
						NoDeal,
						#[codec(index = 30)]
						FeesNotMet,
						#[codec(index = 31)]
						LockError,
						#[codec(index = 32)]
						NoPermission,
						#[codec(index = 33)]
						Unanchored,
						#[codec(index = 34)]
						NotDepositable,
						#[codec(index = 35)]
						UnhandledXcmVersion,
						#[codec(index = 36)]
						WeightLimitReached(::sp_weights::Weight),
						#[codec(index = 37)]
						Barrier,
						#[codec(index = 38)]
						WeightNotComputable,
						#[codec(index = 39)]
						ExceedsStackLimit,
					}
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Instruction {
					#[codec(index = 0)]
					WithdrawAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 1)]
					ReserveAssetDeposited(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 2)]
					ReceiveTeleportedAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 3)]
					QueryResponse {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						response: runtime_types::xcm::v3::Response,
						max_weight: ::sp_weights::Weight,
						querier: ::core::option::Option<
							runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						>,
					},
					#[codec(index = 4)]
					TransferAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssets,
						beneficiary: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 5)]
					TransferReserveAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssets,
						dest: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 6)]
					Transact {
						origin_kind: runtime_types::xcm::v3::OriginKind,
						require_weight_at_most: ::sp_weights::Weight,
						call: runtime_types::xcm::double_encoded::DoubleEncoded,
					},
					#[codec(index = 7)]
					HrmpNewChannelOpenRequest {
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						max_message_size: ::core::primitive::u32,
						#[codec(compact)]
						max_capacity: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					HrmpChannelAccepted {
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 9)]
					HrmpChannelClosing {
						#[codec(compact)]
						initiator: ::core::primitive::u32,
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 10)]
					ClearOrigin,
					#[codec(index = 11)]
					DescendOrigin(runtime_types::xcm::v3::junctions::Junctions),
					#[codec(index = 12)]
					ReportError(runtime_types::xcm::v3::QueryResponseInfo),
					#[codec(index = 13)]
					DepositAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						beneficiary: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 14)]
					DepositReserveAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						dest: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 15)]
					ExchangeAsset {
						give: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						want: runtime_types::xcm::v3::multiasset::MultiAssets,
						maximal: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					InitiateReserveWithdraw {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						reserve: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 17)]
					InitiateTeleport {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						dest: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 18)]
					ReportHolding {
						response_info: runtime_types::xcm::v3::QueryResponseInfo,
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
					},
					#[codec(index = 19)]
					BuyExecution {
						fees: runtime_types::xcm::v3::multiasset::MultiAsset,
						weight_limit: runtime_types::xcm::v3::WeightLimit,
					},
					#[codec(index = 20)]
					RefundSurplus,
					#[codec(index = 21)]
					SetErrorHandler(runtime_types::xcm::v3::Xcm),
					#[codec(index = 22)]
					SetAppendix(runtime_types::xcm::v3::Xcm),
					#[codec(index = 23)]
					ClearError,
					#[codec(index = 24)]
					ClaimAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssets,
						ticket: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 25)]
					Trap(#[codec(compact)] ::core::primitive::u64),
					#[codec(index = 26)]
					SubscribeVersion {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						max_response_weight: ::sp_weights::Weight,
					},
					#[codec(index = 27)]
					UnsubscribeVersion,
					#[codec(index = 28)]
					BurnAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 29)]
					ExpectAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 30)]
					ExpectOrigin(
						::core::option::Option<
							runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						>,
					),
					#[codec(index = 31)]
					ExpectError(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v3::traits::Error,
						)>,
					),
					#[codec(index = 32)]
					ExpectTransactStatus(runtime_types::xcm::v3::MaybeErrorCode),
					#[codec(index = 33)]
					QueryPallet {
						module_name:
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						response_info: runtime_types::xcm::v3::QueryResponseInfo,
					},
					#[codec(index = 34)]
					ExpectPallet {
						#[codec(compact)]
						index: ::core::primitive::u32,
						name: ::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						module_name:
							::subxt::ext::subxt_core::alloc::vec::Vec<::core::primitive::u8>,
						#[codec(compact)]
						crate_major: ::core::primitive::u32,
						#[codec(compact)]
						min_crate_minor: ::core::primitive::u32,
					},
					#[codec(index = 35)]
					ReportTransactStatus(runtime_types::xcm::v3::QueryResponseInfo),
					#[codec(index = 36)]
					ClearTransactStatus,
					#[codec(index = 37)]
					UniversalOrigin(runtime_types::xcm::v3::junction::Junction),
					#[codec(index = 38)]
					ExportMessage {
						network: runtime_types::xcm::v3::junction::NetworkId,
						destination: runtime_types::xcm::v3::junctions::Junctions,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 39)]
					LockAsset {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						unlocker: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 40)]
					UnlockAsset {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						target: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 41)]
					NoteUnlockable {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						owner: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 42)]
					RequestUnlock {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						locker: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 43)]
					SetFeesMode { jit_withdraw: ::core::primitive::bool },
					#[codec(index = 44)]
					SetTopic([::core::primitive::u8; 32usize]),
					#[codec(index = 45)]
					ClearTopic,
					#[codec(index = 46)]
					AliasOrigin(runtime_types::staging_xcm::v3::multilocation::MultiLocation),
					#[codec(index = 47)]
					UnpaidExecution {
						weight_limit: runtime_types::xcm::v3::WeightLimit,
						check_origin: ::core::option::Option<
							runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						>,
					},
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum MaybeErrorCode {
					#[codec(index = 0)]
					Success,
					#[codec(index = 1)]
					Error(
						runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					),
					#[codec(index = 2)]
					TruncatedError(
						runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					),
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum OriginKind {
					#[codec(index = 0)]
					Native,
					#[codec(index = 1)]
					SovereignAccount,
					#[codec(index = 2)]
					Superuser,
					#[codec(index = 3)]
					Xcm,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct PalletInfo {
					#[codec(compact)]
					pub index: ::core::primitive::u32,
					pub name: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					pub module_name: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					#[codec(compact)]
					pub major: ::core::primitive::u32,
					#[codec(compact)]
					pub minor: ::core::primitive::u32,
					#[codec(compact)]
					pub patch: ::core::primitive::u32,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct QueryResponseInfo {
					pub destination: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					#[codec(compact)]
					pub query_id: ::core::primitive::u64,
					pub max_weight: ::sp_weights::Weight,
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum Response {
					#[codec(index = 0)]
					Null,
					#[codec(index = 1)]
					Assets(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 2)]
					ExecutionResult(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v3::traits::Error,
						)>,
					),
					#[codec(index = 3)]
					Version(::core::primitive::u32),
					#[codec(index = 4)]
					PalletsInfo(
						runtime_types::bounded_collections::bounded_vec::BoundedVec<
							runtime_types::xcm::v3::PalletInfo,
						>,
					),
					#[codec(index = 5)]
					DispatchResult(runtime_types::xcm::v3::MaybeErrorCode),
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub enum WeightLimit {
					#[codec(index = 0)]
					Unlimited,
					#[codec(index = 1)]
					Limited(::sp_weights::Weight),
				}
				#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
				pub struct Xcm(
					pub  ::subxt::ext::subxt_core::alloc::vec::Vec<
						runtime_types::xcm::v3::Instruction,
					>,
				);
			}
			pub mod v5 {
				use super::runtime_types;
				pub mod traits {
					use super::runtime_types;
					#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
					pub enum Error {
						#[codec(index = 0)]
						Overflow,
						#[codec(index = 1)]
						Unimplemented,
						#[codec(index = 2)]
						UntrustedReserveLocation,
						#[codec(index = 3)]
						UntrustedTeleportLocation,
						#[codec(index = 4)]
						LocationFull,
						#[codec(index = 5)]
						LocationNotInvertible,
						#[codec(index = 6)]
						BadOrigin,
						#[codec(index = 7)]
						InvalidLocation,
						#[codec(index = 8)]
						AssetNotFound,
						#[codec(index = 9)]
						FailedToTransactAsset,
						#[codec(index = 10)]
						NotWithdrawable,
						#[codec(index = 11)]
						LocationCannotHold,
						#[codec(index = 12)]
						ExceedsMaxMessageSize,
						#[codec(index = 13)]
						DestinationUnsupported,
						#[codec(index = 14)]
						Transport,
						#[codec(index = 15)]
						Unroutable,
						#[codec(index = 16)]
						UnknownClaim,
						#[codec(index = 17)]
						FailedToDecode,
						#[codec(index = 18)]
						MaxWeightInvalid,
						#[codec(index = 19)]
						NotHoldingFees,
						#[codec(index = 20)]
						TooExpensive,
						#[codec(index = 21)]
						Trap(::core::primitive::u64),
						#[codec(index = 22)]
						ExpectationFalse,
						#[codec(index = 23)]
						PalletNotFound,
						#[codec(index = 24)]
						NameMismatch,
						#[codec(index = 25)]
						VersionIncompatible,
						#[codec(index = 26)]
						HoldingWouldOverflow,
						#[codec(index = 27)]
						ExportError,
						#[codec(index = 28)]
						ReanchorFailed,
						#[codec(index = 29)]
						NoDeal,
						#[codec(index = 30)]
						FeesNotMet,
						#[codec(index = 31)]
						LockError,
						#[codec(index = 32)]
						NoPermission,
						#[codec(index = 33)]
						Unanchored,
						#[codec(index = 34)]
						NotDepositable,
						#[codec(index = 35)]
						TooManyAssets,
						#[codec(index = 36)]
						UnhandledXcmVersion,
						#[codec(index = 37)]
						WeightLimitReached(::sp_weights::Weight),
						#[codec(index = 38)]
						Barrier,
						#[codec(index = 39)]
						WeightNotComputable,
						#[codec(index = 40)]
						ExceedsStackLimit,
					}
				}
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum VersionedAssetId {
				#[codec(index = 3)]
				V3(runtime_types::xcm::v3::multiasset::AssetId),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::asset::AssetId),
				#[codec(index = 5)]
				V5(runtime_types::staging_xcm::v5::asset::AssetId),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum VersionedAssets {
				#[codec(index = 3)]
				V3(runtime_types::xcm::v3::multiasset::MultiAssets),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::asset::Assets),
				#[codec(index = 5)]
				V5(runtime_types::staging_xcm::v5::asset::Assets),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum VersionedInteriorLocation {
				#[codec(index = 3)]
				V3(runtime_types::xcm::v3::junctions::Junctions),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::junctions::Junctions),
				#[codec(index = 5)]
				V5(runtime_types::staging_xcm::v5::junctions::Junctions),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum VersionedLocation {
				#[codec(index = 3)]
				V3(runtime_types::staging_xcm::v3::multilocation::MultiLocation),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::location::Location),
				#[codec(index = 5)]
				V5(runtime_types::staging_xcm::v5::location::Location),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum VersionedResponse {
				#[codec(index = 3)]
				V3(runtime_types::xcm::v3::Response),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::Response),
				#[codec(index = 5)]
				V5(runtime_types::staging_xcm::v5::Response),
			}
			#[derive(::codec::Decode, ::codec::Encode, Clone, Debug, PartialEq)]
			pub enum VersionedXcm {
				#[codec(index = 3)]
				V3(runtime_types::xcm::v3::Xcm),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::Xcm),
				#[codec(index = 5)]
				V5(runtime_types::staging_xcm::v5::Xcm),
			}
		}
	}
}
