#![feature(prelude_import)]
#![doc = " Substrate GRANDPA Pallet"]
#![doc = ""]
#![doc = " This pallet is an on-chain GRANDPA light client for Substrate based chains."]
#![doc = ""]
#![doc = " This pallet achieves this by trustlessly verifying GRANDPA finality proofs on-chain. Once"]
#![doc = " verified, finalized headers are stored in the pallet, thereby creating a sparse header chain."]
#![doc = " This sparse header chain can be used as a source of truth for other higher-level applications."]
#![doc = ""]
#![doc = " The pallet is responsible for tracking GRANDPA validator set hand-offs. We only import headers"]
#![doc = " with justifications signed by the current validator set we know of. The header is inspected for"]
#![doc = " a `ScheduledChanges` digest item, which is then used to update to next validator set."]
#![doc = ""]
#![doc = " Since this pallet only tracks finalized headers it does not deal with forks. Forks can only"]
#![doc = " occur if the GRANDPA validator set on the bridged chain is either colluding or there is a severe"]
#![doc = " bug causing resulting in an equivocation. Such events are outside of the scope of this pallet."]
#![doc = " Shall the fork occur on the bridged chain governance intervention will be required to"]
#![doc = " re-initialize the bridge and track the right fork."]
#![allow(clippy::large_enum_variant)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
use crate::weights::WeightInfo;
use bp_header_chain::justification::GrandpaJustification;
use bp_runtime::{BlockNumberOf, Chain, HashOf, HasherOf, HeaderOf};
use codec::{Decode, Encode};
use finality_grandpa::voter_set::VoterSet;
use frame_support::ensure;
use frame_system::{ensure_signed, RawOrigin};
#[cfg(feature = "std")]
use serde::{Deserialize, Serialize};
use sp_finality_grandpa::{ConsensusLog, GRANDPA_ENGINE_ID};
use sp_runtime::traits::{BadOrigin, Header as HeaderT, Zero};
use sp_runtime::RuntimeDebug;
#[doc = " Pallet containing weights for this pallet."]
pub mod weights {
    #![doc = " Autogenerated weights for pallet_bridge_grandpa"]
    #![doc = ""]
    #![doc = " THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 3.0.0"]
    #![doc = " DATE: 2021-04-02, STEPS: [50, ], REPEAT: 20"]
    #![doc = " LOW RANGE: [], HIGH RANGE: []"]
    #![doc = " EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled"]
    #![doc = " CHAIN: Some(\"dev\"), DB CACHE: 128"]
    #![allow(clippy::all)]
    #![allow(unused_parens)]
    #![allow(unused_imports)]
    use frame_support::{
        traits::Get,
        weights::{constants::RocksDbWeight, Weight},
    };
    use sp_std::marker::PhantomData;
    #[doc = " Weight functions needed for pallet_bridge_grandpa."]
    pub trait WeightInfo {
        fn submit_finality_proof(v: u32, p: u32) -> Weight;
        fn submit_finality_proof_on_single_fork(v: u32) -> Weight;
        fn submit_finality_proof_on_many_forks(p: u32) -> Weight;
        fn find_scheduled_change(n: u32) -> Weight;
        fn read_write_authority_sets(n: u32) -> Weight;
    }
    #[doc = " Weights for pallet_bridge_grandpa using the Rialto node and recommended hardware."]
    pub struct RialtoWeight<T>(PhantomData<T>);
    impl<T: frame_system::Config> WeightInfo for RialtoWeight<T> {
        fn submit_finality_proof(v: u32, p: u32) -> Weight {
            (0 as Weight)
                .saturating_add((160_060_000 as Weight).saturating_mul(v as Weight))
                .saturating_add((640_223_000 as Weight).saturating_mul(p as Weight))
                .saturating_add(T::DbWeight::get().reads(5 as Weight))
                .saturating_add(T::DbWeight::get().writes(3 as Weight))
        }
        fn submit_finality_proof_on_single_fork(v: u32) -> Weight {
            (189_597_000 as Weight)
                .saturating_add((11_680_000 as Weight).saturating_mul(v as Weight))
                .saturating_add(T::DbWeight::get().reads(5 as Weight))
                .saturating_add(T::DbWeight::get().writes(3 as Weight))
        }
        fn submit_finality_proof_on_many_forks(p: u32) -> Weight {
            (0 as Weight)
                .saturating_add((130_061_000 as Weight).saturating_mul(p as Weight))
                .saturating_add(T::DbWeight::get().reads(5 as Weight))
                .saturating_add(T::DbWeight::get().writes(3 as Weight))
        }
        fn find_scheduled_change(n: u32) -> Weight {
            (502_000 as Weight).saturating_add((8_000 as Weight).saturating_mul(n as Weight))
        }
        fn read_write_authority_sets(n: u32) -> Weight {
            (7_677_000 as Weight)
                .saturating_add((230_000 as Weight).saturating_mul(n as Weight))
                .saturating_add(T::DbWeight::get().reads(1 as Weight))
                .saturating_add(T::DbWeight::get().writes(1 as Weight))
        }
    }
    impl WeightInfo for () {
        fn submit_finality_proof(v: u32, p: u32) -> Weight {
            (0 as Weight)
                .saturating_add((160_060_000 as Weight).saturating_mul(v as Weight))
                .saturating_add((640_223_000 as Weight).saturating_mul(p as Weight))
                .saturating_add(RocksDbWeight::get().reads(5 as Weight))
                .saturating_add(RocksDbWeight::get().writes(3 as Weight))
        }
        fn submit_finality_proof_on_single_fork(v: u32) -> Weight {
            (189_597_000 as Weight)
                .saturating_add((11_680_000 as Weight).saturating_mul(v as Weight))
                .saturating_add(RocksDbWeight::get().reads(5 as Weight))
                .saturating_add(RocksDbWeight::get().writes(3 as Weight))
        }
        fn submit_finality_proof_on_many_forks(p: u32) -> Weight {
            (0 as Weight)
                .saturating_add((130_061_000 as Weight).saturating_mul(p as Weight))
                .saturating_add(RocksDbWeight::get().reads(5 as Weight))
                .saturating_add(RocksDbWeight::get().writes(3 as Weight))
        }
        fn find_scheduled_change(n: u32) -> Weight {
            (502_000 as Weight).saturating_add((8_000 as Weight).saturating_mul(n as Weight))
        }
        fn read_write_authority_sets(n: u32) -> Weight {
            (7_677_000 as Weight)
                .saturating_add((230_000 as Weight).saturating_mul(n as Weight))
                .saturating_add(RocksDbWeight::get().reads(1 as Weight))
                .saturating_add(RocksDbWeight::get().writes(1 as Weight))
        }
    }
}
pub use pallet::*;
#[doc = " Block number of the bridged chain."]
pub type BridgedBlockNumber<T, I> = BlockNumberOf<<T as Config<I>>::BridgedChain>;
#[doc = " Block hash of the bridged chain."]
pub type BridgedBlockHash<T, I> = HashOf<<T as Config<I>>::BridgedChain>;
#[doc = " Hasher of the bridged chain."]
pub type BridgedBlockHasher<T, I> = HasherOf<<T as Config<I>>::BridgedChain>;
#[doc = " Header of the bridged chain."]
pub type BridgedHeader<T, I> = HeaderOf<<T as Config<I>>::BridgedChain>;
#[doc = r"
			The module that hosts all the
			[FRAME](https://substrate.dev/docs/en/knowledgebase/runtime/frame)
			types needed to add this pallet to a
			[runtime](https://substrate.dev/docs/en/knowledgebase/runtime/).
			"]
pub mod pallet {
    use super::*;
    use frame_support::pallet_prelude::*;
    use frame_system::pallet_prelude::*;
    #[doc = r"
			Configuration trait of this pallet.

			Implement this type for a runtime in order to customize this pallet.
			"]
    pub trait Config<I: 'static = ()>: frame_system::Config {
        #[doc = " The chain we are bridging to here."]
        type BridgedChain: Chain;
        #[doc = " The upper bound on the number of requests allowed by the pallet."]
        #[doc = ""]
        #[doc = " A request refers to an action which writes a header to storage."]
        #[doc = ""]
        #[doc = " Once this bound is reached the pallet will not allow any dispatchables to be called"]
        #[doc = " until the request count has decreased."]
        type MaxRequests: Get<u32>;
        #[doc = " Weights gathered through benchmarking."]
        type WeightInfo: WeightInfo;
    }
    #[doc = r"
			The [pallet](https://substrate.dev/docs/en/knowledgebase/runtime/pallets) implementing
			the on-chain logic.
			"]
    pub struct Pallet<T, I = ()>(PhantomData<(T, I)>);
    const _: () = {
        impl<T, I> core::clone::Clone for Pallet<T, I> {
            fn clone(&self) -> Self {
                Self(core::clone::Clone::clone(&self.0))
            }
        }
    };
    const _: () = {
        impl<T, I> core::cmp::Eq for Pallet<T, I> {}
    };
    const _: () = {
        impl<T, I> core::cmp::PartialEq for Pallet<T, I> {
            fn eq(&self, other: &Self) -> bool {
                true && self.0 == other.0
            }
        }
    };
    const _: () = {
        impl<T, I> core::fmt::Debug for Pallet<T, I> {
            fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                fmt.debug_tuple("Pallet").field(&self.0).finish()
            }
        }
    };
    impl<T: Config<I>, I: 'static> Hooks<BlockNumberFor<T>> for Pallet<T, I> {
        fn on_initialize(_n: T::BlockNumber) -> frame_support::weights::Weight {
            <RequestCount<T, I>>::mutate(|count| *count = count.saturating_sub(1));
            (0_u64)
                .saturating_add(T::DbWeight::get().reads(1))
                .saturating_add(T::DbWeight::get().writes(1))
        }
    }
    impl<T: Config<I>, I: 'static> Pallet<T, I> {
        #[doc = " Verify a target header is finalized according to the given finality proof."]
        #[doc = ""]
        #[doc = " It will use the underlying storage pallet to fetch information about the current"]
        #[doc = " authorities and best finalized header in order to verify that the header is finalized."]
        #[doc = ""]
        #[doc = " If successful in verification, it will write the target header to the underlying storage"]
        #[doc = " pallet."]
        pub fn submit_finality_proof(
            origin: OriginFor<T>,
            finality_target: BridgedHeader<T, I>,
            justification: GrandpaJustification<BridgedHeader<T, I>>,
        ) -> DispatchResultWithPostInfo {
            ensure_operational::<T, I>()?;
            let _ = ensure_signed(origin)?;
            {
                if !(Self::request_count() < T::MaxRequests::get()) {
                    {
                        return Err(<Error<T, I>>::TooManyRequests.into());
                    };
                }
            };
            let (hash, number) = (finality_target.hash(), finality_target.number());
            {
                let lvl = ::log::Level::Trace;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &["Going to try and finalize header "],
                            &match (&finality_target,) {
                                (arg0,) => {
                                    [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)]
                                }
                            },
                        ),
                        lvl,
                        &(
                            "runtime::bridge-grandpa",
                            "pallet_bridge_grandpa::pallet",
                            "modules/grandpa/src/lib.rs",
                            139u32,
                        ),
                    );
                }
            };
            let best_finalized = <ImportedHeaders<T, I>>::get(<BestFinalized<T, I>>::get()).expect(
                "In order to reach this point the bridge must have been initialized. Afterwards,
				every time `BestFinalized` is updated `ImportedHeaders` is also updated. Therefore
				`ImportedHeaders` must contain an entry for `BestFinalized`.",
            );
            {
                if !(best_finalized.number() < number) {
                    {
                        return Err(<Error<T, I>>::OldHeader.into());
                    };
                }
            };
            let authority_set = <CurrentAuthoritySet<T, I>>::get();
            let set_id = authority_set.set_id;
            verify_justification::<T, I>(&justification, hash, *number, authority_set)?;
            let _enacted = try_enact_authority_change::<T, I>(&finality_target, set_id)?;
            <BestFinalized<T, I>>::put(hash);
            <ImportedHeaders<T, I>>::insert(hash, finality_target);
            <RequestCount<T, I>>::mutate(|count| *count += 1);
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &["Succesfully imported finalized header with hash ", "!"],
                            &match (&hash,) {
                                (arg0,) => {
                                    [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)]
                                }
                            },
                        ),
                        lvl,
                        &(
                            "runtime::bridge-grandpa",
                            "pallet_bridge_grandpa::pallet",
                            "modules/grandpa/src/lib.rs",
                            160u32,
                        ),
                    );
                }
            };
            Ok(().into())
        }
        #[doc = " Bootstrap the bridge pallet with an initial header and authority set from which to sync."]
        #[doc = ""]
        #[doc = " The initial configuration provided does not need to be the genesis header of the bridged"]
        #[doc = " chain, it can be any arbirary header. You can also provide the next scheduled set change"]
        #[doc = " if it is already know."]
        #[doc = ""]
        #[doc = " This function is only allowed to be called from a trusted origin and writes to storage"]
        #[doc = " with practically no checks in terms of the validity of the data. It is important that"]
        #[doc = " you ensure that valid data is being passed in."]
        pub fn initialize(
            origin: OriginFor<T>,
            init_data: super::InitializationData<BridgedHeader<T, I>>,
        ) -> DispatchResultWithPostInfo {
            ensure_owner_or_root::<T, I>(origin)?;
            let init_allowed = !<BestFinalized<T, I>>::exists();
            {
                if !init_allowed {
                    {
                        return Err(<Error<T, I>>::AlreadyInitialized.into());
                    };
                }
            };
            initialize_bridge::<T, I>(init_data.clone());
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &["Pallet has been initialized with the following parameters: "],
                            &match (&init_data,) {
                                (arg0,) => {
                                    [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)]
                                }
                            },
                        ),
                        lvl,
                        &(
                            "runtime::bridge-grandpa",
                            "pallet_bridge_grandpa::pallet",
                            "modules/grandpa/src/lib.rs",
                            185u32,
                        ),
                    );
                }
            };
            Ok(().into())
        }
        #[doc = " Change `PalletOwner`."]
        #[doc = ""]
        #[doc = " May only be called either by root, or by `PalletOwner`."]
        pub fn set_owner(
            origin: OriginFor<T>,
            new_owner: Option<T::AccountId>,
        ) -> DispatchResultWithPostInfo {
            ensure_owner_or_root::<T, I>(origin)?;
            match new_owner {
                Some(new_owner) => {
                    PalletOwner::<T, I>::put(&new_owner);
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api_log(
                                ::core::fmt::Arguments::new_v1(
                                    &["Setting pallet Owner to: "],
                                    &match (&new_owner,) {
                                        (arg0,) => [::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Debug::fmt,
                                        )],
                                    },
                                ),
                                lvl,
                                &(
                                    "runtime::bridge-grandpa",
                                    "pallet_bridge_grandpa::pallet",
                                    "modules/grandpa/src/lib.rs",
                                    203u32,
                                ),
                            );
                        }
                    };
                }
                None => {
                    PalletOwner::<T, I>::kill();
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api_log(
                                ::core::fmt::Arguments::new_v1(
                                    &["Removed Owner of pallet."],
                                    &match () {
                                        () => [],
                                    },
                                ),
                                lvl,
                                &(
                                    "runtime::bridge-grandpa",
                                    "pallet_bridge_grandpa::pallet",
                                    "modules/grandpa/src/lib.rs",
                                    207u32,
                                ),
                            );
                        }
                    };
                }
            }
            Ok(().into())
        }
        #[doc = " Halt or resume all pallet operations."]
        #[doc = ""]
        #[doc = " May only be called either by root, or by `PalletOwner`."]
        pub fn set_operational(
            origin: OriginFor<T>,
            operational: bool,
        ) -> DispatchResultWithPostInfo {
            ensure_owner_or_root::<T, I>(origin)?;
            <IsHalted<T, I>>::put(operational);
            if operational {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            ::core::fmt::Arguments::new_v1(
                                &["Resuming pallet operations."],
                                &match () {
                                    () => [],
                                },
                            ),
                            lvl,
                            &(
                                "runtime::bridge-grandpa",
                                "pallet_bridge_grandpa::pallet",
                                "modules/grandpa/src/lib.rs",
                                223u32,
                            ),
                        );
                    }
                };
            } else {
                {
                    let lvl = ::log::Level::Warn;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            ::core::fmt::Arguments::new_v1(
                                &["Stopping pallet operations."],
                                &match () {
                                    () => [],
                                },
                            ),
                            lvl,
                            &(
                                "runtime::bridge-grandpa",
                                "pallet_bridge_grandpa::pallet",
                                "modules/grandpa/src/lib.rs",
                                225u32,
                            ),
                        );
                    }
                };
            }
            Ok(().into())
        }
    }
    #[doc = " The current number of requests which have written to storage."]
    #[doc = ""]
    #[doc = " If the `RequestCount` hits `MaxRequests`, no more calls will be allowed to the pallet until"]
    #[doc = " the request capacity is increased."]
    #[doc = ""]
    #[doc = " The `RequestCount` is decreased by one at the beginning of every block. This is to ensure"]
    #[doc = " that the pallet can always make progress."]
    #[allow(type_alias_bounds)]
    pub(super) type RequestCount<T: Config<I>, I: 'static = ()> =
        StorageValue<_GeneratedPrefixForStorageRequestCount<T, I>, u32, ValueQuery>;
    #[doc = " Hash of the header used to bootstrap the pallet."]
    #[allow(type_alias_bounds)]
    pub(super) type InitialHash<T: Config<I>, I: 'static = ()> = StorageValue<
        _GeneratedPrefixForStorageInitialHash<T, I>,
        BridgedBlockHash<T, I>,
        ValueQuery,
    >;
    #[doc = " Hash of the best finalized header."]
    #[allow(type_alias_bounds)]
    pub(super) type BestFinalized<T: Config<I>, I: 'static = ()> = StorageValue<
        _GeneratedPrefixForStorageBestFinalized<T, I>,
        BridgedBlockHash<T, I>,
        ValueQuery,
    >;
    #[doc = " Headers which have been imported into the pallet."]
    #[allow(type_alias_bounds)]
    pub(super) type ImportedHeaders<T: Config<I>, I: 'static = ()> = StorageMap<
        _GeneratedPrefixForStorageImportedHeaders<T, I>,
        Identity,
        BridgedBlockHash<T, I>,
        BridgedHeader<T, I>,
    >;
    #[doc = " The current GRANDPA Authority set."]
    #[allow(type_alias_bounds)]
    pub(super) type CurrentAuthoritySet<T: Config<I>, I: 'static = ()> = StorageValue<
        _GeneratedPrefixForStorageCurrentAuthoritySet<T, I>,
        bp_header_chain::AuthoritySet,
        ValueQuery,
    >;
    #[doc = " Optional pallet owner."]
    #[doc = ""]
    #[doc = " Pallet owner has a right to halt all pallet operations and then resume it. If it is"]
    #[doc = " `None`, then there are no direct ways to halt/resume pallet operations, but other"]
    #[doc = " runtime methods may still be used to do that (i.e. democracy::referendum to update halt"]
    #[doc = " flag directly or call the `halt_operations`)."]
    #[allow(type_alias_bounds)]
    pub(super) type PalletOwner<T: Config<I>, I: 'static = ()> =
        StorageValue<_GeneratedPrefixForStoragePalletOwner<T, I>, T::AccountId, OptionQuery>;
    #[doc = " If true, all pallet transactions are failed immediately."]
    #[allow(type_alias_bounds)]
    pub(super) type IsHalted<T: Config<I>, I: 'static = ()> =
        StorageValue<_GeneratedPrefixForStorageIsHalted<T, I>, bool, ValueQuery>;
    #[doc = r"
					Can be used to configure the
					[genesis state](https://substrate.dev/docs/en/knowledgebase/integrate/chain-spec#the-genesis-state)
					of this pallet.
					"]
    #[cfg(feature = "std")]
    #[serde(rename_all = "camelCase")]
    #[serde(deny_unknown_fields)]
    #[serde(bound(serialize = ""))]
    #[serde(bound(deserialize = ""))]
    pub struct GenesisConfig<T: Config<I>, I: 'static = ()> {
        #[doc = " Optional module owner account."]
        pub owner: Option<T::AccountId>,
        #[doc = " Optional module initialization data."]
        pub init_data: Option<super::InitializationData<BridgedHeader<T, I>>>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<T: Config<I>, I: 'static> _serde::Serialize for GenesisConfig<T, I> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "GenesisConfig",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "owner",
                    &self.owner,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "initData",
                    &self.init_data,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, T: Config<I>, I: 'static> _serde::Deserialize<'de> for GenesisConfig<T, I> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "owner" => _serde::__private::Ok(__Field::__field0),
                            "initData" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_field(
                                __value, FIELDS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"owner" => _serde::__private::Ok(__Field::__field0),
                            b"initData" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_field(
                                    __value, FIELDS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, T: Config<I>, I: 'static> {
                    marker: _serde::__private::PhantomData<GenesisConfig<T, I>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, T: Config<I>, I: 'static> _serde::de::Visitor<'de> for __Visitor<'de, T, I> {
                    type Value = GenesisConfig<T, I>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct GenesisConfig")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Option<T::AccountId>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct GenesisConfig with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<super::InitializationData<BridgedHeader<T, I>>>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct GenesisConfig with 2 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(GenesisConfig {
                            owner: __field0,
                            init_data: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<T::AccountId>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<super::InitializationData<BridgedHeader<T, I>>>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "owner",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<T::AccountId>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "initData",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<super::InitializationData<BridgedHeader<T, I>>>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("owner") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("initData") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(GenesisConfig {
                            owner: __field0,
                            init_data: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["owner", "initData"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "GenesisConfig",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<GenesisConfig<T, I>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[cfg(feature = "std")]
    impl<T: Config<I>, I: 'static> Default for GenesisConfig<T, I> {
        fn default() -> Self {
            Self {
                owner: None,
                init_data: None,
            }
        }
    }
    #[cfg(feature = "std")]
    impl<T: Config<I>, I: 'static> GenesisBuild<T, I> for GenesisConfig<T, I> {
        fn build(&self) {
            if let Some(ref owner) = self.owner {
                <PalletOwner<T, I>>::put(owner);
            }
            if let Some(init_data) = self.init_data.clone() {
                initialize_bridge::<T, I>(init_data);
            } else {
                <IsHalted<T, I>>::put(true);
            }
        }
    }
    #[doc = r"
			Custom [dispatch errors](https://substrate.dev/docs/en/knowledgebase/runtime/errors)
			of this pallet.
			"]
    pub enum Error<T, I = ()> {
        #[doc(hidden)]
        __Ignore(
            frame_support::sp_std::marker::PhantomData<(T, I)>,
            frame_support::Never,
        ),
        #[doc = " The given justification is invalid for the given header."]
        InvalidJustification,
        #[doc = " The authority set from the underlying header chain is invalid."]
        InvalidAuthoritySet,
        #[doc = " There are too many requests for the current window to handle."]
        TooManyRequests,
        #[doc = " The header being imported is older than the best finalized header known to the pallet."]
        OldHeader,
        #[doc = " The header is unknown to the pallet."]
        UnknownHeader,
        #[doc = " The scheduled authority set change found in the header is unsupported by the pallet."]
        #[doc = ""]
        #[doc = " This is the case for non-standard (e.g forced) authority set changes."]
        UnsupportedScheduledChange,
        #[doc = " The pallet has already been initialized."]
        AlreadyInitialized,
        #[doc = " All pallet operations are halted."]
        Halted,
        #[doc = " The storage proof doesn\'t contains storage root. So it is invalid for given header."]
        StorageRootMismatch,
    }
    #[doc = " Check the given header for a GRANDPA scheduled authority set change. If a change"]
    #[doc = " is found it will be enacted immediately."]
    #[doc = ""]
    #[doc = " This function does not support forced changes, or scheduled changes with delays"]
    #[doc = " since these types of changes are indicitive of abnormal behaviour from GRANDPA."]
    #[doc = ""]
    #[doc = " Returned value will indicate if a change was enacted or not."]
    pub(crate) fn try_enact_authority_change<T: Config<I>, I: 'static>(
        header: &BridgedHeader<T, I>,
        current_set_id: sp_finality_grandpa::SetId,
    ) -> Result<bool, sp_runtime::DispatchError> {
        let mut change_enacted = false;
        {
            if !super::find_forced_change(header).is_none() {
                {
                    return Err(<Error<T, I>>::UnsupportedScheduledChange.into());
                };
            }
        };
        if let Some(change) = super::find_scheduled_change(header) {
            {
                if !(change.delay == Zero::zero()) {
                    {
                        return Err(<Error<T, I>>::UnsupportedScheduledChange.into());
                    };
                }
            };
            let next_authorities = bp_header_chain::AuthoritySet {
                authorities: change.next_authorities,
                set_id: current_set_id + 1,
            };
            <CurrentAuthoritySet<T, I>>::put(&next_authorities);
            change_enacted = true;
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &[
                                "Transitioned from authority set ",
                                " to ",
                                "! New authorities are: ",
                            ],
                            &match (&current_set_id, &(current_set_id + 1), &next_authorities) {
                                (arg0, arg1, arg2) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Debug::fmt),
                                ],
                            },
                        ),
                        lvl,
                        &(
                            "runtime::bridge-grandpa",
                            "pallet_bridge_grandpa::pallet",
                            "modules/grandpa/src/lib.rs",
                            367u32,
                        ),
                    );
                }
            };
        };
        Ok(change_enacted)
    }
    #[doc = " Verify a GRANDPA justification (finality proof) for a given header."]
    #[doc = ""]
    #[doc = " Will use the GRANDPA current authorities known to the pallet."]
    #[doc = ""]
    #[doc = " If succesful it returns the decoded GRANDPA justification so we can refund any weight which"]
    #[doc = " was overcharged in the initial call."]
    pub(crate) fn verify_justification<T: Config<I>, I: 'static>(
        justification: &GrandpaJustification<BridgedHeader<T, I>>,
        hash: BridgedBlockHash<T, I>,
        number: BridgedBlockNumber<T, I>,
        authority_set: bp_header_chain::AuthoritySet,
    ) -> Result<(), sp_runtime::DispatchError> {
        use bp_header_chain::justification::verify_justification;
        let voter_set =
            VoterSet::new(authority_set.authorities).ok_or(<Error<T, I>>::InvalidAuthoritySet)?;
        let set_id = authority_set.set_id;
        Ok(verify_justification::<BridgedHeader<T, I>>(
            (hash, number),
            set_id,
            &voter_set,
            &justification,
        )
        .map_err(|e| {
            {
                let lvl = ::log::Level::Error;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &["Received invalid justification for ", ": "],
                            &match (&hash, &e) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                                ],
                            },
                        ),
                        lvl,
                        &(
                            "runtime::bridge-grandpa",
                            "pallet_bridge_grandpa::pallet",
                            "modules/grandpa/src/lib.rs",
                            399u32,
                        ),
                    );
                }
            };
            <Error<T, I>>::InvalidJustification
        })?)
    }
    #[doc = " Since this writes to storage with no real checks this should only be used in functions that"]
    #[doc = " were called by a trusted origin."]
    pub(crate) fn initialize_bridge<T: Config<I>, I: 'static>(
        init_params: super::InitializationData<BridgedHeader<T, I>>,
    ) {
        let super::InitializationData {
            header,
            authority_list,
            set_id,
            is_halted,
        } = init_params;
        let initial_hash = header.hash();
        <InitialHash<T, I>>::put(initial_hash);
        <BestFinalized<T, I>>::put(initial_hash);
        <ImportedHeaders<T, I>>::insert(initial_hash, header);
        let authority_set = bp_header_chain::AuthoritySet::new(authority_list, set_id);
        <CurrentAuthoritySet<T, I>>::put(authority_set);
        <IsHalted<T, I>>::put(is_halted);
    }
    #[doc = " Ensure that the origin is either root, or `PalletOwner`."]
    fn ensure_owner_or_root<T: Config<I>, I: 'static>(origin: T::Origin) -> Result<(), BadOrigin> {
        match origin.into() {
            Ok(RawOrigin::Root) => Ok(()),
            Ok(RawOrigin::Signed(ref signer))
                if Some(signer) == <PalletOwner<T, I>>::get().as_ref() =>
            {
                Ok(())
            }
            _ => Err(BadOrigin),
        }
    }
    #[doc = " Ensure that the pallet is in operational mode (not halted)."]
    fn ensure_operational<T: Config<I>, I: 'static>() -> Result<(), Error<T, I>> {
        if <IsHalted<T, I>>::get() {
            Err(<Error<T, I>>::Halted)
        } else {
            Ok(())
        }
    }
    impl<T: Config<I>, I: 'static> Pallet<T, I> {
        #[doc(hidden)]
        pub fn module_constants_metadata(
        ) -> &'static [frame_support::dispatch::ModuleConstantMetadata] {
            &[{
                #[allow(non_upper_case_types)]
                #[allow(non_camel_case_types)]
                struct MaxRequestsDefaultByteGetter<T, I = ()>(
                    frame_support::sp_std::marker::PhantomData<(T, I)>,
                );
                impl<T: Config<I>, I: 'static> frame_support::dispatch::DefaultByte
                    for MaxRequestsDefaultByteGetter<T, I>
                {
                    fn default_byte(&self) -> frame_support::sp_std::vec::Vec<u8> {
                        let value = <T::MaxRequests as frame_support::traits::Get<u32>>::get();
                        frame_support::codec::Encode::encode(&value)
                    }
                }
                unsafe impl<T: Config<I>, I: 'static> Send for MaxRequestsDefaultByteGetter<T, I> {}
                unsafe impl<T: Config<I>, I: 'static> Sync for MaxRequestsDefaultByteGetter<T, I> {}
                frame_support :: dispatch :: ModuleConstantMetadata { name : frame_support :: dispatch :: DecodeDifferent :: Encode ("MaxRequests") , ty : frame_support :: dispatch :: DecodeDifferent :: Encode ("u32") , value : frame_support :: dispatch :: DecodeDifferent :: Encode (frame_support :: dispatch :: DefaultByteGetter (& MaxRequestsDefaultByteGetter :: < T , I > (frame_support :: sp_std :: marker :: PhantomData))) , documentation : frame_support :: dispatch :: DecodeDifferent :: Encode (& [" The upper bound on the number of requests allowed by the pallet." , "" , " A request refers to an action which writes a header to storage." , "" , " Once this bound is reached the pallet will not allow any dispatchables to be called" , " until the request count has decreased."]) , }
            }]
        }
    }
    impl<T: Config<I>, I: 'static> frame_support::error::ModuleErrorMetadata for Pallet<T, I> {
        fn metadata() -> &'static [frame_support::error::ErrorMetadata] {
            <Error<T, I> as frame_support::error::ModuleErrorMetadata>::metadata()
        }
    }
    #[doc = r" Type alias to `Pallet`, to be used by `construct_runtime`."]
    #[doc = r""]
    #[doc = r" Generated by `pallet` attribute macro."]
    #[deprecated(note = "use `Pallet` instead")]
    #[allow(dead_code)]
    pub type Module<T, I = ()> = Pallet<T, I>;
    impl<T: Config<I>, I: 'static> frame_support::traits::GetPalletVersion for Pallet<T, I> {
        fn current_version() -> frame_support::traits::PalletVersion {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
        }
        fn storage_version() -> Option<frame_support::traits::PalletVersion> {
            let key = frame_support::traits::PalletVersion::storage_key::<
                <T as frame_system::Config>::PalletInfo,
                Self,
            >()
            .expect("Every active pallet has a name in the runtime; qed");
            frame_support::storage::unhashed::get(&key)
        }
    }
    impl<T: Config<I>, I: 'static> frame_support::traits::OnGenesis for Pallet<T, I> {
        fn on_genesis() {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
        }
    }
    #[doc = r"Contains one variant per dispatchable that can be called by an extrinsic."]
    #[allow(non_camel_case_types)]
    pub enum Call<T: Config<I>, I: 'static = ()> {
        #[doc(hidden)]
        #[codec(skip)]
        __Ignore(
            frame_support::sp_std::marker::PhantomData<(T, I)>,
            frame_support::Never,
        ),
        #[doc = " Verify a target header is finalized according to the given finality proof."]
        #[doc = ""]
        #[doc = " It will use the underlying storage pallet to fetch information about the current"]
        #[doc = " authorities and best finalized header in order to verify that the header is finalized."]
        #[doc = ""]
        #[doc = " If successful in verification, it will write the target header to the underlying storage"]
        #[doc = " pallet."]
        submit_finality_proof(
            BridgedHeader<T, I>,
            GrandpaJustification<BridgedHeader<T, I>>,
        ),
        #[doc = " Bootstrap the bridge pallet with an initial header and authority set from which to sync."]
        #[doc = ""]
        #[doc = " The initial configuration provided does not need to be the genesis header of the bridged"]
        #[doc = " chain, it can be any arbirary header. You can also provide the next scheduled set change"]
        #[doc = " if it is already know."]
        #[doc = ""]
        #[doc = " This function is only allowed to be called from a trusted origin and writes to storage"]
        #[doc = " with practically no checks in terms of the validity of the data. It is important that"]
        #[doc = " you ensure that valid data is being passed in."]
        initialize(super::InitializationData<BridgedHeader<T, I>>),
        #[doc = " Change `PalletOwner`."]
        #[doc = ""]
        #[doc = " May only be called either by root, or by `PalletOwner`."]
        set_owner(Option<T::AccountId>),
        #[doc = " Halt or resume all pallet operations."]
        #[doc = ""]
        #[doc = " May only be called either by root, or by `PalletOwner`."]
        set_operational(bool),
    }
    const _: () = {
        impl<T: Config<I>, I: 'static> core::fmt::Debug for Call<T, I> {
            fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
                match *self {
                    Self::__Ignore(ref _0, ref _1) => fmt
                        .debug_tuple("Call::__Ignore")
                        .field(&_0)
                        .field(&_1)
                        .finish(),
                    Self::submit_finality_proof(ref _0, ref _1) => fmt
                        .debug_tuple("Call::submit_finality_proof")
                        .field(&_0)
                        .field(&_1)
                        .finish(),
                    Self::initialize(ref _0) => {
                        fmt.debug_tuple("Call::initialize").field(&_0).finish()
                    }
                    Self::set_owner(ref _0) => {
                        fmt.debug_tuple("Call::set_owner").field(&_0).finish()
                    }
                    Self::set_operational(ref _0) => {
                        fmt.debug_tuple("Call::set_operational").field(&_0).finish()
                    }
                }
            }
        }
    };
    const _: () = {
        impl<T: Config<I>, I: 'static> core::clone::Clone for Call<T, I> {
            fn clone(&self) -> Self {
                match self {
                    Self::__Ignore(ref _0, ref _1) => {
                        Self::__Ignore(core::clone::Clone::clone(_0), core::clone::Clone::clone(_1))
                    }
                    Self::submit_finality_proof(ref _0, ref _1) => Self::submit_finality_proof(
                        core::clone::Clone::clone(_0),
                        core::clone::Clone::clone(_1),
                    ),
                    Self::initialize(ref _0) => Self::initialize(core::clone::Clone::clone(_0)),
                    Self::set_owner(ref _0) => Self::set_owner(core::clone::Clone::clone(_0)),
                    Self::set_operational(ref _0) => {
                        Self::set_operational(core::clone::Clone::clone(_0))
                    }
                }
            }
        }
    };
    const _: () = {
        impl<T: Config<I>, I: 'static> core::cmp::Eq for Call<T, I> {}
    };
    const _: () = {
        impl<T: Config<I>, I: 'static> core::cmp::PartialEq for Call<T, I> {
            fn eq(&self, other: &Self) -> bool {
                match (self, other) {
                    (Self::__Ignore(_0, _1), Self::__Ignore(_0_other, _1_other)) => {
                        true && _0 == _0_other && _1 == _1_other
                    }
                    (
                        Self::submit_finality_proof(_0, _1),
                        Self::submit_finality_proof(_0_other, _1_other),
                    ) => true && _0 == _0_other && _1 == _1_other,
                    (Self::initialize(_0), Self::initialize(_0_other)) => true && _0 == _0_other,
                    (Self::set_owner(_0), Self::set_owner(_0_other)) => true && _0 == _0_other,
                    (Self::set_operational(_0), Self::set_operational(_0_other)) => {
                        true && _0 == _0_other
                    }
                    (Self::__Ignore { .. }, Self::submit_finality_proof { .. }) => false,
                    (Self::__Ignore { .. }, Self::initialize { .. }) => false,
                    (Self::__Ignore { .. }, Self::set_owner { .. }) => false,
                    (Self::__Ignore { .. }, Self::set_operational { .. }) => false,
                    (Self::submit_finality_proof { .. }, Self::__Ignore { .. }) => false,
                    (Self::submit_finality_proof { .. }, Self::initialize { .. }) => false,
                    (Self::submit_finality_proof { .. }, Self::set_owner { .. }) => false,
                    (Self::submit_finality_proof { .. }, Self::set_operational { .. }) => false,
                    (Self::initialize { .. }, Self::__Ignore { .. }) => false,
                    (Self::initialize { .. }, Self::submit_finality_proof { .. }) => false,
                    (Self::initialize { .. }, Self::set_owner { .. }) => false,
                    (Self::initialize { .. }, Self::set_operational { .. }) => false,
                    (Self::set_owner { .. }, Self::__Ignore { .. }) => false,
                    (Self::set_owner { .. }, Self::submit_finality_proof { .. }) => false,
                    (Self::set_owner { .. }, Self::initialize { .. }) => false,
                    (Self::set_owner { .. }, Self::set_operational { .. }) => false,
                    (Self::set_operational { .. }, Self::__Ignore { .. }) => false,
                    (Self::set_operational { .. }, Self::submit_finality_proof { .. }) => false,
                    (Self::set_operational { .. }, Self::initialize { .. }) => false,
                    (Self::set_operational { .. }, Self::set_owner { .. }) => false,
                }
            }
        }
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Config<I>, I: 'static> _parity_scale_codec::Encode for Call<T, I>
        where
            BridgedHeader<T, I>: _parity_scale_codec::Encode,
            BridgedHeader<T, I>: _parity_scale_codec::Encode,
            GrandpaJustification<BridgedHeader<T, I>>: _parity_scale_codec::Encode,
            GrandpaJustification<BridgedHeader<T, I>>: _parity_scale_codec::Encode,
            super::InitializationData<BridgedHeader<T, I>>: _parity_scale_codec::Encode,
            super::InitializationData<BridgedHeader<T, I>>: _parity_scale_codec::Encode,
            Option<T::AccountId>: _parity_scale_codec::Encode,
            Option<T::AccountId>: _parity_scale_codec::Encode,
        {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output + ?Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Call::submit_finality_proof(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                        _parity_scale_codec::Encode::encode_to(ba, __codec_dest_edqy);
                    }
                    Call::initialize(ref aa) => {
                        __codec_dest_edqy.push_byte(1usize as u8);
                        _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    }
                    Call::set_owner(ref aa) => {
                        __codec_dest_edqy.push_byte(2usize as u8);
                        _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    }
                    Call::set_operational(ref aa) => {
                        __codec_dest_edqy.push_byte(3usize as u8);
                        _parity_scale_codec::Encode::encode_to(aa, __codec_dest_edqy);
                    }
                    _ => (),
                }
            }
        }
        impl<T: Config<I>, I: 'static> _parity_scale_codec::EncodeLike for Call<T, I>
        where
            BridgedHeader<T, I>: _parity_scale_codec::Encode,
            BridgedHeader<T, I>: _parity_scale_codec::Encode,
            GrandpaJustification<BridgedHeader<T, I>>: _parity_scale_codec::Encode,
            GrandpaJustification<BridgedHeader<T, I>>: _parity_scale_codec::Encode,
            super::InitializationData<BridgedHeader<T, I>>: _parity_scale_codec::Encode,
            super::InitializationData<BridgedHeader<T, I>>: _parity_scale_codec::Encode,
            Option<T::AccountId>: _parity_scale_codec::Encode,
            Option<T::AccountId>: _parity_scale_codec::Encode,
        {
        }
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Config<I>, I: 'static> _parity_scale_codec::Decode for Call<T, I>
        where
            BridgedHeader<T, I>: _parity_scale_codec::Decode,
            BridgedHeader<T, I>: _parity_scale_codec::Decode,
            GrandpaJustification<BridgedHeader<T, I>>: _parity_scale_codec::Decode,
            GrandpaJustification<BridgedHeader<T, I>>: _parity_scale_codec::Decode,
            super::InitializationData<BridgedHeader<T, I>>: _parity_scale_codec::Decode,
            super::InitializationData<BridgedHeader<T, I>>: _parity_scale_codec::Decode,
            Option<T::AccountId>: _parity_scale_codec::Decode,
            Option<T::AccountId>: _parity_scale_codec::Decode,
        {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy
                    .read_byte()
                    .map_err(|e| e.chain("Could not decode `Call`, failed to read variant byte"))?
                {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => {
                        Ok(Call::<T, I>::submit_finality_proof(
                            {
                                let __codec_res_edqy =
                                    <BridgedHeader<T, I> as _parity_scale_codec::Decode>::decode(
                                        __codec_input_edqy,
                                    );
                                match __codec_res_edqy {
                                    Err(e) => {
                                        return Err(e.chain(
                                            "Could not decode `Call::submit_finality_proof.0`",
                                        ))
                                    }
                                    Ok(__codec_res_edqy) => __codec_res_edqy,
                                }
                            },
                            {
                                let __codec_res_edqy = < GrandpaJustification < BridgedHeader < T , I > > as _parity_scale_codec :: Decode > :: decode (__codec_input_edqy) ;
                                match __codec_res_edqy {
                                    Err(e) => {
                                        return Err(e.chain(
                                            "Could not decode `Call::submit_finality_proof.1`",
                                        ))
                                    }
                                    Ok(__codec_res_edqy) => __codec_res_edqy,
                                }
                            },
                        ))
                    }
                    __codec_x_edqy if __codec_x_edqy == 1usize as u8 => {
                        Ok(Call::<T, I>::initialize({
                            let __codec_res_edqy = < super :: InitializationData < BridgedHeader < T , I > > as _parity_scale_codec :: Decode > :: decode (__codec_input_edqy) ;
                            match __codec_res_edqy {
                                Err(e) => {
                                    return Err(e.chain("Could not decode `Call::initialize.0`"))
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        }))
                    }
                    __codec_x_edqy if __codec_x_edqy == 2usize as u8 => {
                        Ok(Call::<T, I>::set_owner({
                            let __codec_res_edqy =
                                <Option<T::AccountId> as _parity_scale_codec::Decode>::decode(
                                    __codec_input_edqy,
                                );
                            match __codec_res_edqy {
                                Err(e) => {
                                    return Err(e.chain("Could not decode `Call::set_owner.0`"))
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        }))
                    }
                    __codec_x_edqy if __codec_x_edqy == 3usize as u8 => {
                        Ok(Call::<T, I>::set_operational({
                            let __codec_res_edqy =
                                <bool as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(e) => {
                                    return Err(
                                        e.chain("Could not decode `Call::set_operational.0`")
                                    )
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        }))
                    }
                    _ => Err("Could not decode `Call`, variant doesn\'t exist".into()),
                }
            }
        }
    };
    impl<T: Config<I>, I: 'static> frame_support::dispatch::GetDispatchInfo for Call<T, I> {
        fn get_dispatch_info(&self) -> frame_support::dispatch::DispatchInfo {
            match *self {
                Self::submit_finality_proof(ref finality_target, ref justification) => {
                    let __pallet_base_weight = T::WeightInfo::submit_finality_proof(
                        justification.votes_ancestries.len() as u32,
                        justification.commit.precommits.len() as u32,
                    );
                    let __pallet_weight = <dyn frame_support::dispatch::WeighData<(
                        &BridgedHeader<T, I>,
                        &GrandpaJustification<BridgedHeader<T, I>>,
                    )>>::weigh_data(
                        &__pallet_base_weight, (finality_target, justification)
                    );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &BridgedHeader<T, I>,
                        &GrandpaJustification<BridgedHeader<T, I>>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight, (finality_target, justification)
                    );
                    let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<(
                        &BridgedHeader<T, I>,
                        &GrandpaJustification<BridgedHeader<T, I>>,
                    )>>::pays_fee(
                        &__pallet_base_weight,
                        (finality_target, justification),
                    );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::initialize(ref init_data) => {
                    let __pallet_base_weight = (
                        T::DbWeight::get().reads_writes(2, 5),
                        DispatchClass::Operational,
                    );
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(
                            &super::InitializationData<BridgedHeader<T, I>>,
                        )>>::weigh_data(&__pallet_base_weight, (init_data,));
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &super::InitializationData<BridgedHeader<T, I>>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight, (init_data,)
                    );
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(
                            &super::InitializationData<BridgedHeader<T, I>>,
                        )>>::pays_fee(&__pallet_base_weight, (init_data,));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_owner(ref new_owner) => {
                    let __pallet_base_weight = (
                        T::DbWeight::get().reads_writes(1, 1),
                        DispatchClass::Operational,
                    );
                    let __pallet_weight = <dyn frame_support::dispatch::WeighData<(
                        &Option<T::AccountId>,
                    )>>::weigh_data(
                        &__pallet_base_weight, (new_owner,)
                    );
                    let __pallet_class = <dyn frame_support::dispatch::ClassifyDispatch<(
                        &Option<T::AccountId>,
                    )>>::classify_dispatch(
                        &__pallet_base_weight, (new_owner,)
                    );
                    let __pallet_pays_fee = <dyn frame_support::dispatch::PaysFee<(
                        &Option<T::AccountId>,
                    )>>::pays_fee(
                        &__pallet_base_weight, (new_owner,)
                    );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_operational(ref operational) => {
                    let __pallet_base_weight = (
                        T::DbWeight::get().reads_writes(1, 1),
                        DispatchClass::Operational,
                    );
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&bool,)>>::weigh_data(
                            &__pallet_base_weight,
                            (operational,),
                        );
                    let __pallet_class = < dyn frame_support :: dispatch :: ClassifyDispatch < (& bool ,) > > :: classify_dispatch (& __pallet_base_weight , (operational ,)) ;
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&bool,)>>::pays_fee(
                            &__pallet_base_weight,
                            (operational,),
                        );
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__Ignore cannot be used",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Config<I>, I: 'static> frame_support::dispatch::GetCallName for Call<T, I> {
        fn get_call_name(&self) -> &'static str {
            match *self {
                Self::submit_finality_proof(..) => "submit_finality_proof",
                Self::initialize(..) => "initialize",
                Self::set_owner(..) => "set_owner",
                Self::set_operational(..) => "set_operational",
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem cannot be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
        fn get_call_names() -> &'static [&'static str] {
            &[
                "submit_finality_proof",
                "initialize",
                "set_owner",
                "set_operational",
            ]
        }
    }
    impl<T: Config<I>, I: 'static> frame_support::traits::UnfilteredDispatchable for Call<T, I> {
        type Origin = frame_system::pallet_prelude::OriginFor<T>;
        fn dispatch_bypass_filter(
            self,
            origin: Self::Origin,
        ) -> frame_support::dispatch::DispatchResultWithPostInfo {
            match self {
                Self::submit_finality_proof(finality_target, justification) => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "submit_finality_proof",
                                    "pallet_bridge_grandpa::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("modules/grandpa/src/lib.rs"),
                                    Some(74u32),
                                    Some("pallet_bridge_grandpa::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && CALLSITE.is_enabled(interest)
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = CALLSITE.disabled_span();
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    <Pallet<T, I>>::submit_finality_proof(origin, finality_target, justification)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Self::initialize(init_data) => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "initialize",
                                    "pallet_bridge_grandpa::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("modules/grandpa/src/lib.rs"),
                                    Some(74u32),
                                    Some("pallet_bridge_grandpa::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && CALLSITE.is_enabled(interest)
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = CALLSITE.disabled_span();
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    <Pallet<T, I>>::initialize(origin, init_data)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Self::set_owner(new_owner) => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "set_owner",
                                    "pallet_bridge_grandpa::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("modules/grandpa/src/lib.rs"),
                                    Some(74u32),
                                    Some("pallet_bridge_grandpa::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && CALLSITE.is_enabled(interest)
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = CALLSITE.disabled_span();
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    <Pallet<T, I>>::set_owner(origin, new_owner)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Self::set_operational(operational) => {
                    let __within_span__ = {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "set_operational",
                                    "pallet_bridge_grandpa::pallet",
                                    ::tracing::Level::TRACE,
                                    Some("modules/grandpa/src/lib.rs"),
                                    Some(74u32),
                                    Some("pallet_bridge_grandpa::pallet"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = CALLSITE.interest();
                                !interest.is_never()
                            }
                            && CALLSITE.is_enabled(interest)
                        {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = CALLSITE.disabled_span();
                            {};
                            span
                        }
                    };
                    let __tracing_guard__ = __within_span__.enter();
                    <Pallet<T, I>>::set_operational(origin, operational)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Self::__Ignore(_, _) => {
                    let _ = origin;
                    {
                        {
                            ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                &["internal error: entered unreachable code: "],
                                &match (&"__PhantomItem cannot be used.",) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Display::fmt,
                                    )],
                                },
                            ))
                        }
                    };
                }
            }
        }
    }
    impl<T: Config<I>, I: 'static> frame_support::dispatch::Callable<T> for Pallet<T, I> {
        type Call = Call<T, I>;
    }
    impl<T: Config<I>, I: 'static> Pallet<T, I> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn call_functions() -> &'static [frame_support::dispatch::FunctionMetadata] {
            & [frame_support :: dispatch :: FunctionMetadata { name : frame_support :: dispatch :: DecodeDifferent :: Encode ("submit_finality_proof") , arguments : frame_support :: dispatch :: DecodeDifferent :: Encode (& [frame_support :: dispatch :: FunctionArgumentMetadata { name : frame_support :: dispatch :: DecodeDifferent :: Encode ("finality_target") , ty : frame_support :: dispatch :: DecodeDifferent :: Encode ("BridgedHeader<T, I>") , } , frame_support :: dispatch :: FunctionArgumentMetadata { name : frame_support :: dispatch :: DecodeDifferent :: Encode ("justification") , ty : frame_support :: dispatch :: DecodeDifferent :: Encode ("GrandpaJustification<BridgedHeader<T, I>>") , }]) , documentation : frame_support :: dispatch :: DecodeDifferent :: Encode (& [" Verify a target header is finalized according to the given finality proof." , "" , " It will use the underlying storage pallet to fetch information about the current" , " authorities and best finalized header in order to verify that the header is finalized." , "" , " If successful in verification, it will write the target header to the underlying storage" , " pallet."]) , } , frame_support :: dispatch :: FunctionMetadata { name : frame_support :: dispatch :: DecodeDifferent :: Encode ("initialize") , arguments : frame_support :: dispatch :: DecodeDifferent :: Encode (& [frame_support :: dispatch :: FunctionArgumentMetadata { name : frame_support :: dispatch :: DecodeDifferent :: Encode ("init_data") , ty : frame_support :: dispatch :: DecodeDifferent :: Encode ("super::InitializationData<BridgedHeader<T, I>>") , }]) , documentation : frame_support :: dispatch :: DecodeDifferent :: Encode (& [" Bootstrap the bridge pallet with an initial header and authority set from which to sync." , "" , " The initial configuration provided does not need to be the genesis header of the bridged" , " chain, it can be any arbirary header. You can also provide the next scheduled set change" , " if it is already know." , "" , " This function is only allowed to be called from a trusted origin and writes to storage" , " with practically no checks in terms of the validity of the data. It is important that" , " you ensure that valid data is being passed in."]) , } , frame_support :: dispatch :: FunctionMetadata { name : frame_support :: dispatch :: DecodeDifferent :: Encode ("set_owner") , arguments : frame_support :: dispatch :: DecodeDifferent :: Encode (& [frame_support :: dispatch :: FunctionArgumentMetadata { name : frame_support :: dispatch :: DecodeDifferent :: Encode ("new_owner") , ty : frame_support :: dispatch :: DecodeDifferent :: Encode ("Option<T::AccountId>") , }]) , documentation : frame_support :: dispatch :: DecodeDifferent :: Encode (& [" Change `PalletOwner`." , "" , " May only be called either by root, or by `PalletOwner`."]) , } , frame_support :: dispatch :: FunctionMetadata { name : frame_support :: dispatch :: DecodeDifferent :: Encode ("set_operational") , arguments : frame_support :: dispatch :: DecodeDifferent :: Encode (& [frame_support :: dispatch :: FunctionArgumentMetadata { name : frame_support :: dispatch :: DecodeDifferent :: Encode ("operational") , ty : frame_support :: dispatch :: DecodeDifferent :: Encode ("bool") , }]) , documentation : frame_support :: dispatch :: DecodeDifferent :: Encode (& [" Halt or resume all pallet operations." , "" , " May only be called either by root, or by `PalletOwner`."]) , }]
        }
    }
    impl<T: Config<I>, I: 'static> frame_support::sp_std::fmt::Debug for Error<T, I> {
        fn fmt(
            &self,
            f: &mut frame_support::sp_std::fmt::Formatter<'_>,
        ) -> frame_support::sp_std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl<T: Config<I>, I: 'static> Error<T, I> {
        pub fn as_u8(&self) -> u8 {
            match &self {
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Self::InvalidJustification => 0usize as u8,
                Self::InvalidAuthoritySet => 1usize as u8,
                Self::TooManyRequests => 2usize as u8,
                Self::OldHeader => 3usize as u8,
                Self::UnknownHeader => 4usize as u8,
                Self::UnsupportedScheduledChange => 5usize as u8,
                Self::AlreadyInitialized => 6usize as u8,
                Self::Halted => 7usize as u8,
                Self::StorageRootMismatch => 8usize as u8,
            }
        }
        pub fn as_str(&self) -> &'static str {
            match &self {
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Self::InvalidJustification => "InvalidJustification",
                Self::InvalidAuthoritySet => "InvalidAuthoritySet",
                Self::TooManyRequests => "TooManyRequests",
                Self::OldHeader => "OldHeader",
                Self::UnknownHeader => "UnknownHeader",
                Self::UnsupportedScheduledChange => "UnsupportedScheduledChange",
                Self::AlreadyInitialized => "AlreadyInitialized",
                Self::Halted => "Halted",
                Self::StorageRootMismatch => "StorageRootMismatch",
            }
        }
    }
    impl<T: Config<I>, I: 'static> From<Error<T, I>> for &'static str {
        fn from(err: Error<T, I>) -> &'static str {
            err.as_str()
        }
    }
    impl<T: Config<I>, I: 'static> From<Error<T, I>> for frame_support::sp_runtime::DispatchError {
        fn from(err: Error<T, I>) -> Self {
            let index = < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: index :: < Pallet < T , I > > () . expect ("Every active module has an index in the runtime; qed") as u8 ;
            frame_support::sp_runtime::DispatchError::Module {
                index,
                error: err.as_u8(),
                message: Some(err.as_str()),
            }
        }
    }
    impl<T: Config<I>, I: 'static> frame_support::error::ModuleErrorMetadata for Error<T, I> {
        fn metadata() -> &'static [frame_support::error::ErrorMetadata] {
            & [frame_support :: error :: ErrorMetadata { name : frame_support :: error :: DecodeDifferent :: Encode ("InvalidJustification") , documentation : frame_support :: error :: DecodeDifferent :: Encode (& [" The given justification is invalid for the given header."]) , } , frame_support :: error :: ErrorMetadata { name : frame_support :: error :: DecodeDifferent :: Encode ("InvalidAuthoritySet") , documentation : frame_support :: error :: DecodeDifferent :: Encode (& [" The authority set from the underlying header chain is invalid."]) , } , frame_support :: error :: ErrorMetadata { name : frame_support :: error :: DecodeDifferent :: Encode ("TooManyRequests") , documentation : frame_support :: error :: DecodeDifferent :: Encode (& [" There are too many requests for the current window to handle."]) , } , frame_support :: error :: ErrorMetadata { name : frame_support :: error :: DecodeDifferent :: Encode ("OldHeader") , documentation : frame_support :: error :: DecodeDifferent :: Encode (& [" The header being imported is older than the best finalized header known to the pallet."]) , } , frame_support :: error :: ErrorMetadata { name : frame_support :: error :: DecodeDifferent :: Encode ("UnknownHeader") , documentation : frame_support :: error :: DecodeDifferent :: Encode (& [" The header is unknown to the pallet."]) , } , frame_support :: error :: ErrorMetadata { name : frame_support :: error :: DecodeDifferent :: Encode ("UnsupportedScheduledChange") , documentation : frame_support :: error :: DecodeDifferent :: Encode (& [" The scheduled authority set change found in the header is unsupported by the pallet." , "" , " This is the case for non-standard (e.g forced) authority set changes."]) , } , frame_support :: error :: ErrorMetadata { name : frame_support :: error :: DecodeDifferent :: Encode ("AlreadyInitialized") , documentation : frame_support :: error :: DecodeDifferent :: Encode (& [" The pallet has already been initialized."]) , } , frame_support :: error :: ErrorMetadata { name : frame_support :: error :: DecodeDifferent :: Encode ("Halted") , documentation : frame_support :: error :: DecodeDifferent :: Encode (& [" All pallet operations are halted."]) , } , frame_support :: error :: ErrorMetadata { name : frame_support :: error :: DecodeDifferent :: Encode ("StorageRootMismatch") , documentation : frame_support :: error :: DecodeDifferent :: Encode (& [" The storage proof doesn\'t contains storage root. So it is invalid for given header."]) , }]
        }
    }
    impl<T: Config<I>, I: 'static> Pallet<T, I> {
        #[doc(hidden)]
        pub fn storage_metadata() -> frame_support::metadata::StorageMetadata {
            frame_support :: metadata :: StorageMetadata { prefix : frame_support :: metadata :: DecodeDifferent :: Encode (< < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Pallet < T , I > > () . expect ("Every active pallet has a name in the runtime; qed")) , entries : frame_support :: metadata :: DecodeDifferent :: Encode (& [frame_support :: metadata :: StorageEntryMetadata { name : frame_support :: metadata :: DecodeDifferent :: Encode (< RequestCount < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: NAME) , modifier : < RequestCount < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: MODIFIER , ty : frame_support :: metadata :: StorageEntryType :: Plain (frame_support :: metadata :: DecodeDifferent :: Encode ("u32")) , default : frame_support :: metadata :: DecodeDifferent :: Encode (< RequestCount < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: DEFAULT) , documentation : frame_support :: metadata :: DecodeDifferent :: Encode (& [" The current number of requests which have written to storage." , "" , " If the `RequestCount` hits `MaxRequests`, no more calls will be allowed to the pallet until" , " the request capacity is increased." , "" , " The `RequestCount` is decreased by one at the beginning of every block. This is to ensure" , " that the pallet can always make progress."]) , } , frame_support :: metadata :: StorageEntryMetadata { name : frame_support :: metadata :: DecodeDifferent :: Encode (< InitialHash < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: NAME) , modifier : < InitialHash < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: MODIFIER , ty : frame_support :: metadata :: StorageEntryType :: Plain (frame_support :: metadata :: DecodeDifferent :: Encode ("BridgedBlockHash<T, I>")) , default : frame_support :: metadata :: DecodeDifferent :: Encode (< InitialHash < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: DEFAULT) , documentation : frame_support :: metadata :: DecodeDifferent :: Encode (& [" Hash of the header used to bootstrap the pallet."]) , } , frame_support :: metadata :: StorageEntryMetadata { name : frame_support :: metadata :: DecodeDifferent :: Encode (< BestFinalized < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: NAME) , modifier : < BestFinalized < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: MODIFIER , ty : frame_support :: metadata :: StorageEntryType :: Plain (frame_support :: metadata :: DecodeDifferent :: Encode ("BridgedBlockHash<T, I>")) , default : frame_support :: metadata :: DecodeDifferent :: Encode (< BestFinalized < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: DEFAULT) , documentation : frame_support :: metadata :: DecodeDifferent :: Encode (& [" Hash of the best finalized header."]) , } , frame_support :: metadata :: StorageEntryMetadata { name : frame_support :: metadata :: DecodeDifferent :: Encode (< ImportedHeaders < T , I > as frame_support :: storage :: types :: StorageMapMetadata > :: NAME) , modifier : < ImportedHeaders < T , I > as frame_support :: storage :: types :: StorageMapMetadata > :: MODIFIER , ty : frame_support :: metadata :: StorageEntryType :: Map { hasher : < ImportedHeaders < T , I > as frame_support :: storage :: types :: StorageMapMetadata > :: HASHER , key : frame_support :: metadata :: DecodeDifferent :: Encode ("BridgedBlockHash<T, I>") , value : frame_support :: metadata :: DecodeDifferent :: Encode ("BridgedHeader<T, I>") , unused : false , } , default : frame_support :: metadata :: DecodeDifferent :: Encode (< ImportedHeaders < T , I > as frame_support :: storage :: types :: StorageMapMetadata > :: DEFAULT) , documentation : frame_support :: metadata :: DecodeDifferent :: Encode (& [" Headers which have been imported into the pallet."]) , } , frame_support :: metadata :: StorageEntryMetadata { name : frame_support :: metadata :: DecodeDifferent :: Encode (< CurrentAuthoritySet < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: NAME) , modifier : < CurrentAuthoritySet < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: MODIFIER , ty : frame_support :: metadata :: StorageEntryType :: Plain (frame_support :: metadata :: DecodeDifferent :: Encode ("bp_header_chain::AuthoritySet")) , default : frame_support :: metadata :: DecodeDifferent :: Encode (< CurrentAuthoritySet < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: DEFAULT) , documentation : frame_support :: metadata :: DecodeDifferent :: Encode (& [" The current GRANDPA Authority set."]) , } , frame_support :: metadata :: StorageEntryMetadata { name : frame_support :: metadata :: DecodeDifferent :: Encode (< PalletOwner < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: NAME) , modifier : < PalletOwner < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: MODIFIER , ty : frame_support :: metadata :: StorageEntryType :: Plain (frame_support :: metadata :: DecodeDifferent :: Encode ("T::AccountId")) , default : frame_support :: metadata :: DecodeDifferent :: Encode (< PalletOwner < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: DEFAULT) , documentation : frame_support :: metadata :: DecodeDifferent :: Encode (& [" Optional pallet owner." , "" , " Pallet owner has a right to halt all pallet operations and then resume it. If it is" , " `None`, then there are no direct ways to halt/resume pallet operations, but other" , " runtime methods may still be used to do that (i.e. democracy::referendum to update halt" , " flag directly or call the `halt_operations`)."]) , } , frame_support :: metadata :: StorageEntryMetadata { name : frame_support :: metadata :: DecodeDifferent :: Encode (< IsHalted < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: NAME) , modifier : < IsHalted < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: MODIFIER , ty : frame_support :: metadata :: StorageEntryType :: Plain (frame_support :: metadata :: DecodeDifferent :: Encode ("bool")) , default : frame_support :: metadata :: DecodeDifferent :: Encode (< IsHalted < T , I > as frame_support :: storage :: types :: StorageValueMetadata > :: DEFAULT) , documentation : frame_support :: metadata :: DecodeDifferent :: Encode (& [" If true, all pallet transactions are failed immediately."]) , }]) , }
        }
    }
    impl<T: Config<I>, I: 'static> Pallet<T, I> {
        #[doc = " The current number of requests which have written to storage."]
        #[doc = ""]
        #[doc = " If the `RequestCount` hits `MaxRequests`, no more calls will be allowed to the pallet until"]
        #[doc = " the request capacity is increased."]
        #[doc = ""]
        #[doc = " The `RequestCount` is decreased by one at the beginning of every block. This is to ensure"]
        #[doc = " that the pallet can always make progress."]
        pub fn request_count() -> u32 {
            <RequestCount<T, I> as frame_support::storage::StorageValue<u32>>::get()
        }
    }
    pub(super) struct _GeneratedPrefixForStorageRequestCount<T, I>(
        core::marker::PhantomData<(T, I)>,
    );
    impl<T: Config<I>, I: 'static> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageRequestCount<T, I>
    {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                Pallet<T, I>,
            >()
            .expect("Every active pallet has a name in the runtime; qed")
        }
        const STORAGE_PREFIX: &'static str = "RequestCount";
    }
    pub(super) struct _GeneratedPrefixForStorageInitialHash<T, I>(
        core::marker::PhantomData<(T, I)>,
    );
    impl<T: Config<I>, I: 'static> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageInitialHash<T, I>
    {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                Pallet<T, I>,
            >()
            .expect("Every active pallet has a name in the runtime; qed")
        }
        const STORAGE_PREFIX: &'static str = "InitialHash";
    }
    pub(super) struct _GeneratedPrefixForStorageBestFinalized<T, I>(
        core::marker::PhantomData<(T, I)>,
    );
    impl<T: Config<I>, I: 'static> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageBestFinalized<T, I>
    {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                Pallet<T, I>,
            >()
            .expect("Every active pallet has a name in the runtime; qed")
        }
        const STORAGE_PREFIX: &'static str = "BestFinalized";
    }
    pub(super) struct _GeneratedPrefixForStorageImportedHeaders<T, I>(
        core::marker::PhantomData<(T, I)>,
    );
    impl<T: Config<I>, I: 'static> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageImportedHeaders<T, I>
    {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                Pallet<T, I>,
            >()
            .expect("Every active pallet has a name in the runtime; qed")
        }
        const STORAGE_PREFIX: &'static str = "ImportedHeaders";
    }
    pub(super) struct _GeneratedPrefixForStorageCurrentAuthoritySet<T, I>(
        core::marker::PhantomData<(T, I)>,
    );
    impl<T: Config<I>, I: 'static> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageCurrentAuthoritySet<T, I>
    {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                Pallet<T, I>,
            >()
            .expect("Every active pallet has a name in the runtime; qed")
        }
        const STORAGE_PREFIX: &'static str = "CurrentAuthoritySet";
    }
    pub(super) struct _GeneratedPrefixForStoragePalletOwner<T, I>(
        core::marker::PhantomData<(T, I)>,
    );
    impl<T: Config<I>, I: 'static> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStoragePalletOwner<T, I>
    {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                Pallet<T, I>,
            >()
            .expect("Every active pallet has a name in the runtime; qed")
        }
        const STORAGE_PREFIX: &'static str = "PalletOwner";
    }
    pub(super) struct _GeneratedPrefixForStorageIsHalted<T, I>(core::marker::PhantomData<(T, I)>);
    impl<T: Config<I>, I: 'static> frame_support::traits::StorageInstance
        for _GeneratedPrefixForStorageIsHalted<T, I>
    {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as frame_support::traits::PalletInfo>::name::<
                Pallet<T, I>,
            >()
            .expect("Every active pallet has a name in the runtime; qed")
        }
        const STORAGE_PREFIX: &'static str = "IsHalted";
    }
    #[doc = r" Hidden instance generated to be internally used when module is used without"]
    #[doc = r" instance."]
    #[doc(hidden)]
    pub type __InherentHiddenInstance = ();
    pub use frame_support::instances::Instance0;
    pub use frame_support::instances::Instance1;
    pub use frame_support::instances::Instance2;
    pub use frame_support::instances::Instance3;
    pub use frame_support::instances::Instance4;
    pub use frame_support::instances::Instance5;
    pub use frame_support::instances::Instance6;
    pub use frame_support::instances::Instance7;
    pub use frame_support::instances::Instance8;
    pub use frame_support::instances::Instance9;
    pub use frame_support::instances::Instance10;
    pub use frame_support::instances::Instance11;
    pub use frame_support::instances::Instance12;
    pub use frame_support::instances::Instance13;
    pub use frame_support::instances::Instance14;
    pub use frame_support::instances::Instance15;
    impl<T: Config<I>, I: 'static>
        frame_support::traits::OnFinalize<<T as frame_system::Config>::BlockNumber>
        for Pallet<T, I>
    {
        fn on_finalize(n: <T as frame_system::Config>::BlockNumber) {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_finalize",
                            "pallet_bridge_grandpa::pallet",
                            ::tracing::Level::TRACE,
                            Some("modules/grandpa/src/lib.rs"),
                            Some(74u32),
                            Some("pallet_bridge_grandpa::pallet"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: on_finalize (n)
        }
    }
    impl<T: Config<I>, I: 'static>
        frame_support::traits::OnIdle<<T as frame_system::Config>::BlockNumber> for Pallet<T, I>
    {
        fn on_idle(
            n: <T as frame_system::Config>::BlockNumber,
            remaining_weight: frame_support::weights::Weight,
        ) -> frame_support::weights::Weight {
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: on_idle (n , remaining_weight)
        }
    }
    impl<T: Config<I>, I: 'static>
        frame_support::traits::OnInitialize<<T as frame_system::Config>::BlockNumber>
        for Pallet<T, I>
    {
        fn on_initialize(
            n: <T as frame_system::Config>::BlockNumber,
        ) -> frame_support::weights::Weight {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_initialize",
                            "pallet_bridge_grandpa::pallet",
                            ::tracing::Level::TRACE,
                            Some("modules/grandpa/src/lib.rs"),
                            Some(74u32),
                            Some("pallet_bridge_grandpa::pallet"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: on_initialize (n)
        }
    }
    impl<T: Config<I>, I: 'static> frame_support::traits::OnRuntimeUpgrade for Pallet<T, I> {
        fn on_runtime_upgrade() -> frame_support::weights::Weight {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_runtime_update",
                            "pallet_bridge_grandpa::pallet",
                            ::tracing::Level::TRACE,
                            Some("modules/grandpa/src/lib.rs"),
                            Some(74u32),
                            Some("pallet_bridge_grandpa::pallet"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            let new_storage_version = frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            };
            let pallet_name = < < T as frame_system :: Config > :: PalletInfo as frame_support :: traits :: PalletInfo > :: name :: < Self > () . unwrap_or ("<unknown pallet name>") ;
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &[
                                "\u{2705} no migration for ",
                                ", setting storage version to ",
                            ],
                            &match (&pallet_name, &new_storage_version) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                                ],
                            },
                        ),
                        lvl,
                        &(
                            frame_support::LOG_TARGET,
                            "pallet_bridge_grandpa::pallet",
                            "modules/grandpa/src/lib.rs",
                            74u32,
                        ),
                    );
                }
            };
            let result = <Self as frame_support::traits::Hooks<
                <T as frame_system::Config>::BlockNumber,
            >>::on_runtime_upgrade();
            new_storage_version.put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
            let additional_write =
                <<T as frame_system::Config>::DbWeight as frame_support::traits::Get<_>>::get()
                    .writes(1);
            result.saturating_add(additional_write)
        }
    }
    impl<T: Config<I>, I: 'static>
        frame_support::traits::OffchainWorker<<T as frame_system::Config>::BlockNumber>
        for Pallet<T, I>
    {
        fn offchain_worker(n: <T as frame_system::Config>::BlockNumber) {
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: offchain_worker (n)
        }
    }
    impl<T: Config<I>, I: 'static> frame_support::traits::IntegrityTest for Pallet<T, I> {
        fn integrity_test() {
            < Self as frame_support :: traits :: Hooks < < T as frame_system :: Config > :: BlockNumber > > :: integrity_test ()
        }
    }
    #[cfg(feature = "std")]
    impl<T: Config<I>, I: 'static> frame_support::sp_runtime::BuildModuleGenesisStorage<T, I>
        for GenesisConfig<T, I>
    {
        fn build_module_genesis_storage(
            &self,
            storage: &mut frame_support::sp_runtime::Storage,
        ) -> std::result::Result<(), std::string::String> {
            frame_support::BasicExternalities::execute_with_storage(storage, || {
                <Self as frame_support::traits::GenesisBuild<T, I>>::build(self);
                Ok(())
            })
        }
    }
}
impl<T: Config<I>, I: 'static> Pallet<T, I> {
    #[doc = " Get the best finalized header the pallet knows of."]
    #[doc = ""]
    #[doc = " Returns a dummy header if there is no best header. This can only happen"]
    #[doc = " if the pallet has not been initialized yet."]
    pub fn best_finalized() -> BridgedHeader<T, I> {
        let hash = <BestFinalized<T, I>>::get();
        <ImportedHeaders<T, I>>::get(hash).unwrap_or_else(|| {
            <BridgedHeader<T, I>>::new(
                Default::default(),
                Default::default(),
                Default::default(),
                Default::default(),
                Default::default(),
            )
        })
    }
    #[doc = " Check if a particular header is known to the bridge pallet."]
    pub fn is_known_header(hash: BridgedBlockHash<T, I>) -> bool {
        <ImportedHeaders<T, I>>::contains_key(hash)
    }
    #[doc = " Verify that the passed storage proof is valid, given it is crafted using"]
    #[doc = " known finalized header. If the proof is valid, then the `parse` callback"]
    #[doc = " is called and the function returns its result."]
    pub fn parse_finalized_storage_proof<R>(
        hash: BridgedBlockHash<T, I>,
        storage_proof: sp_trie::StorageProof,
        parse: impl FnOnce(bp_runtime::StorageProofChecker<BridgedBlockHasher<T, I>>) -> R,
    ) -> Result<R, sp_runtime::DispatchError> {
        let header = <ImportedHeaders<T, I>>::get(hash).ok_or(Error::<T, I>::UnknownHeader)?;
        let storage_proof_checker =
            bp_runtime::StorageProofChecker::new(*header.state_root(), storage_proof)
                .map_err(|_| Error::<T, I>::StorageRootMismatch)?;
        Ok(parse(storage_proof_checker))
    }
}
#[doc = " Data required for initializing the bridge pallet."]
#[doc = ""]
#[doc = " The bridge needs to know where to start its sync from, and this provides that initial context."]
pub struct InitializationData<H: HeaderT> {
    #[doc = " The header from which we should start syncing."]
    pub header: H,
    #[doc = " The initial authorities of the pallet."]
    pub authority_list: sp_finality_grandpa::AuthorityList,
    #[doc = " The ID of the initial authority set."]
    pub set_id: sp_finality_grandpa::SetId,
    #[doc = " Should the pallet block transaction immediately after initialization."]
    pub is_halted: bool,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<H: HeaderT> _serde::Serialize for InitializationData<H>
    where
        H: _serde::Serialize,
    {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "InitializationData",
                false as usize + 1 + 1 + 1 + 1,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "header",
                &self.header,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "authority_list",
                &self.authority_list,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "set_id",
                &self.set_id,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "is_halted",
                &self.is_halted,
            ) {
                _serde::__private::Ok(__val) => __val,
                _serde::__private::Err(__err) => {
                    return _serde::__private::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de, H: HeaderT> _serde::Deserialize<'de> for InitializationData<H>
    where
        H: _serde::Deserialize<'de>,
    {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __ignore,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "header" => _serde::__private::Ok(__Field::__field0),
                        "authority_list" => _serde::__private::Ok(__Field::__field1),
                        "set_id" => _serde::__private::Ok(__Field::__field2),
                        "is_halted" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"header" => _serde::__private::Ok(__Field::__field0),
                        b"authority_list" => _serde::__private::Ok(__Field::__field1),
                        b"set_id" => _serde::__private::Ok(__Field::__field2),
                        b"is_halted" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de, H: HeaderT>
            where
                H: _serde::Deserialize<'de>,
            {
                marker: _serde::__private::PhantomData<InitializationData<H>>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de, H: HeaderT> _serde::de::Visitor<'de> for __Visitor<'de, H>
            where
                H: _serde::Deserialize<'de>,
            {
                type Value = InitializationData<H>;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct InitializationData",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match match _serde::de::SeqAccess::next_element::<H>(&mut __seq)
                    {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(_serde::de::Error::invalid_length(
                                0usize,
                                &"struct InitializationData with 4 elements",
                            ));
                        }
                    };
                    let __field1 = match match _serde::de::SeqAccess::next_element::<
                        sp_finality_grandpa::AuthorityList,
                    >(&mut __seq)
                    {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(_serde::de::Error::invalid_length(
                                1usize,
                                &"struct InitializationData with 4 elements",
                            ));
                        }
                    };
                    let __field2 = match match _serde::de::SeqAccess::next_element::<
                        sp_finality_grandpa::SetId,
                    >(&mut __seq)
                    {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(_serde::de::Error::invalid_length(
                                2usize,
                                &"struct InitializationData with 4 elements",
                            ));
                        }
                    };
                    let __field3 =
                        match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct InitializationData with 4 elements",
                                ));
                            }
                        };
                    _serde::__private::Ok(InitializationData {
                        header: __field0,
                        authority_list: __field1,
                        set_id: __field2,
                        is_halted: __field3,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<H> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<
                        sp_finality_grandpa::AuthorityList,
                    > = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<sp_finality_grandpa::SetId> =
                        _serde::__private::None;
                    let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                    while let _serde::__private::Some(__key) =
                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        }
                    {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "header",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<H>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "authority_list",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        sp_finality_grandpa::AuthorityList,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "set_id",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<
                                        sp_finality_grandpa::SetId,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "is_halted",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    match _serde::de::MapAccess::next_value::<bool>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("header") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("authority_list") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("set_id") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            match _serde::__private::de::missing_field("is_halted") {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        }
                    };
                    _serde::__private::Ok(InitializationData {
                        header: __field0,
                        authority_list: __field1,
                        set_id: __field2,
                        is_halted: __field3,
                    })
                }
            }
            const FIELDS: &'static [&'static str] =
                &["header", "authority_list", "set_id", "is_halted"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "InitializationData",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<InitializationData<H>>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
#[allow(unused_qualifications)]
impl<H: ::core::default::Default + HeaderT> ::core::default::Default for InitializationData<H> {
    #[inline]
    fn default() -> InitializationData<H> {
        InitializationData {
            header: ::core::default::Default::default(),
            authority_list: ::core::default::Default::default(),
            set_id: ::core::default::Default::default(),
            is_halted: ::core::default::Default::default(),
        }
    }
}
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl<H: HeaderT> _parity_scale_codec::Encode for InitializationData<H>
    where
        H: _parity_scale_codec::Encode,
        H: _parity_scale_codec::Encode,
    {
        fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output + ?Sized>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            _parity_scale_codec::Encode::encode_to(&self.header, __codec_dest_edqy);
            _parity_scale_codec::Encode::encode_to(&self.authority_list, __codec_dest_edqy);
            _parity_scale_codec::Encode::encode_to(&self.set_id, __codec_dest_edqy);
            _parity_scale_codec::Encode::encode_to(&self.is_halted, __codec_dest_edqy);
        }
    }
    impl<H: HeaderT> _parity_scale_codec::EncodeLike for InitializationData<H>
    where
        H: _parity_scale_codec::Encode,
        H: _parity_scale_codec::Encode,
    {
    }
};
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl<H: HeaderT> _parity_scale_codec::Decode for InitializationData<H>
    where
        H: _parity_scale_codec::Decode,
        H: _parity_scale_codec::Decode,
    {
        fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> core::result::Result<Self, _parity_scale_codec::Error> {
            Ok(InitializationData::<H> {
                header: {
                    let __codec_res_edqy =
                        <H as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        Err(e) => {
                            return Err(e.chain("Could not decode `InitializationData::header`"))
                        }
                        Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                authority_list: {
                    let __codec_res_edqy =
                        <sp_finality_grandpa::AuthorityList as _parity_scale_codec::Decode>::decode(
                            __codec_input_edqy,
                        );
                    match __codec_res_edqy {
                        Err(e) => {
                            return Err(
                                e.chain("Could not decode `InitializationData::authority_list`")
                            )
                        }
                        Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                set_id: {
                    let __codec_res_edqy =
                        <sp_finality_grandpa::SetId as _parity_scale_codec::Decode>::decode(
                            __codec_input_edqy,
                        );
                    match __codec_res_edqy {
                        Err(e) => {
                            return Err(e.chain("Could not decode `InitializationData::set_id`"))
                        }
                        Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
                is_halted: {
                    let __codec_res_edqy =
                        <bool as _parity_scale_codec::Decode>::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        Err(e) => {
                            return Err(e.chain("Could not decode `InitializationData::is_halted`"))
                        }
                        Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                },
            })
        }
    }
};
impl<H: HeaderT> core::fmt::Debug for InitializationData<H>
where
    H: core::fmt::Debug,
{
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        fmt.debug_struct("InitializationData")
            .field("header", &self.header)
            .field("authority_list", &self.authority_list)
            .field("set_id", &self.set_id)
            .field("is_halted", &self.is_halted)
            .finish()
    }
}
impl<H: HeaderT> ::core::marker::StructuralPartialEq for InitializationData<H> {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<H: ::core::cmp::PartialEq + HeaderT> ::core::cmp::PartialEq for InitializationData<H> {
    #[inline]
    fn eq(&self, other: &InitializationData<H>) -> bool {
        match *other {
            InitializationData {
                header: ref __self_1_0,
                authority_list: ref __self_1_1,
                set_id: ref __self_1_2,
                is_halted: ref __self_1_3,
            } => match *self {
                InitializationData {
                    header: ref __self_0_0,
                    authority_list: ref __self_0_1,
                    set_id: ref __self_0_2,
                    is_halted: ref __self_0_3,
                } => {
                    (*__self_0_0) == (*__self_1_0)
                        && (*__self_0_1) == (*__self_1_1)
                        && (*__self_0_2) == (*__self_1_2)
                        && (*__self_0_3) == (*__self_1_3)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &InitializationData<H>) -> bool {
        match *other {
            InitializationData {
                header: ref __self_1_0,
                authority_list: ref __self_1_1,
                set_id: ref __self_1_2,
                is_halted: ref __self_1_3,
            } => match *self {
                InitializationData {
                    header: ref __self_0_0,
                    authority_list: ref __self_0_1,
                    set_id: ref __self_0_2,
                    is_halted: ref __self_0_3,
                } => {
                    (*__self_0_0) != (*__self_1_0)
                        || (*__self_0_1) != (*__self_1_1)
                        || (*__self_0_2) != (*__self_1_2)
                        || (*__self_0_3) != (*__self_1_3)
                }
            },
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<H: ::core::clone::Clone + HeaderT> ::core::clone::Clone for InitializationData<H> {
    #[inline]
    fn clone(&self) -> InitializationData<H> {
        match *self {
            InitializationData {
                header: ref __self_0_0,
                authority_list: ref __self_0_1,
                set_id: ref __self_0_2,
                is_halted: ref __self_0_3,
            } => InitializationData {
                header: ::core::clone::Clone::clone(&(*__self_0_0)),
                authority_list: ::core::clone::Clone::clone(&(*__self_0_1)),
                set_id: ::core::clone::Clone::clone(&(*__self_0_2)),
                is_halted: ::core::clone::Clone::clone(&(*__self_0_3)),
            },
        }
    }
}
pub(crate) fn find_scheduled_change<H: HeaderT>(
    header: &H,
) -> Option<sp_finality_grandpa::ScheduledChange<H::Number>> {
    use sp_runtime::generic::OpaqueDigestItemId;
    let id = OpaqueDigestItemId::Consensus(&GRANDPA_ENGINE_ID);
    let filter_log = |log: ConsensusLog<H::Number>| match log {
        ConsensusLog::ScheduledChange(change) => Some(change),
        _ => None,
    };
    header
        .digest()
        .convert_first(|l| l.try_to(id).and_then(filter_log))
}
#[doc = " Checks the given header for a consensus digest signalling a **forced** scheduled change and"]
#[doc = " extracts it."]
pub(crate) fn find_forced_change<H: HeaderT>(
    header: &H,
) -> Option<(H::Number, sp_finality_grandpa::ScheduledChange<H::Number>)> {
    use sp_runtime::generic::OpaqueDigestItemId;
    let id = OpaqueDigestItemId::Consensus(&GRANDPA_ENGINE_ID);
    let filter_log = |log: ConsensusLog<H::Number>| match log {
        ConsensusLog::ForcedChange(delay, change) => Some((delay, change)),
        _ => None,
    };
    header
        .digest()
        .convert_first(|l| l.try_to(id).and_then(filter_log))
}
